<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>NIO基础 | 「hirikiのblog」</title><meta name="keywords" content="NIO"><meta name="author" content="hiriki"><meta name="copyright" content="hiriki"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="NIO基础"><meta name="application-name" content="NIO基础"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="NIO基础"><meta property="og:url" content="http://www.sherry.zone/posts/e5d14cce.html"><meta property="og:site_name" content="「hirikiのblog」"><meta property="og:description" content="NIO三大组件以及不同IO之间的对比"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://blog-1314261683.cos.ap-chengdu.myqcloud.com/public/四月.jpeg"><meta property="article:author" content="hiriki"><meta property="article:tag" content="Java,算法,代码,博客,Butterfly,Hexo,Ray,hiriki,sherry"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://blog-1314261683.cos.ap-chengdu.myqcloud.com/public/四月.jpeg"><meta name="description" content="NIO三大组件以及不同IO之间的对比"><link rel="shortcut icon" href="https://blog-1314261683.cos.ap-chengdu.myqcloud.com/public%2Ffavicon.ico"><link rel="canonical" href="http://www.sherry.zone/posts/e5d14cce"><link rel="preconnect" href="//cdn.cbd.int"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: undefined,
  postHeadAiDescription: {"enable":true,"gptName":"AnZhiYu","mode":"local","switchBtn":false,"btnLink":"https://afdian.net/item/886a79d4db6711eda42a52540025c377","randomNum":3,"basicWordCount":1000,"key":"xxxx","Referer":"https://xx.xx/"},
  diytitle: {"enable":true,"leaveTitle":"👀跑哪里去了～","backTitle":"🍥欢迎肥来～"},
  LA51: {"enable":true,"ck":"3HwDgY7UEBSxOADx","LingQueMonitorID":"3HwDgY7UEBSxOADx"},
  greetingBox: {"enable":true,"default":"晚上好","list":[{"greeting":"晚安","startTime":0,"endTime":5},{"greeting":"早上好鸭, 祝你一天好心情！","startTime":6,"endTime":9},{"greeting":"上午好, 状态很好，鼓励一下～","startTime":10,"endTime":10},{"greeting":"11点多啦, 在坚持一下就吃饭啦～","startTime":11,"endTime":11},{"greeting":"午安","startTime":12,"endTime":14},{"greeting":"辛苦啦！","startTime":14,"endTime":18},{"greeting":"18点喽, 奖励一顿丰盛的大餐吧。","startTime":18,"endTime":19},{"greeting":"晚上好, 在属于自己的时间好好放松~","startTime":20,"endTime":22}]},
  twikooEnvId: 'https://twikoo.sherry.pub/',
  commentBarrageConfig:undefined,
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: false,
  mainTone: undefined,
  authorStatus: {"skills":["🤖️ 数码科技爱好者","🔍 分享与热心帮助","🏠 智能家居小能手","🔨 设计开发一条龙","🤝 专修交互与设计","🏃 脚踏实地行动派","🧱 团队小组发动机","💢 壮汉人狠话不多"]},
  algolia: {"appId":"UM5B1S43V2","apiKey":"a6b29d3081e9507f77ad033cb51abd1d","indexName":"blog","hits":{"per_page":6},"languages":{"input_placeholder":"输入关键词后按下回车查找","hits_empty":"找不到您查询的内容：${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":230},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: true,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"作者: hiriki","link":"链接: ","source":"来源: 「hirikiのblog」","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: '「hirikiのblog」',
  title: 'NIO基础',
  postAI: '',
  pageFillDescription: 'NIO 三大组件, Channel amp Buffer, Selector, 多线程版设计, ⚠️ 多线程版缺点, 线程池版设计, ⚠️ 线程池版缺点, selector 版设计 , ByteBuffer, ByteBuffer 正确使用姿势, ByteBuffer 结构, 💡 调试工具类, ByteBuffer 常见方法, 分配空间, 向 buffer 写入数据, 从 buffer 读取数据, mark 和 reset, 字符串与 ByteBuffer 互转, ⚠️ Buffer 的线程安全, Scattering Reads 分散读, Gathering Writes 集中写, 练习：网络粘包半包问题, 文件编程, FileChannel, ⚠️ FileChannel 工作模式, 获取, 读取, 写入, 关闭, 位置, 大小, 强制写入, 两个 Channel 传输数据, Path, Files, 网络编程, 阻塞 vs 非阻塞, 阻塞, 非阻塞, 多路复用, Selector, 创建, 绑定 Channel 事件, 监听 Channel 事件, 💡 select 何时不阻塞, 处理 accept 事件, 💡 事件发生后能否不处理, 处理 read 事件, 💡 为何要 keys.remove(), 💡 cancel 的作用, ⚠️ 不处理边界的问题, 处理消息的边界, ByteBuffer 大小分配, 处理 write 事件, 一次无法写完例子, 💡 write 为何要取消, 更进一步, 💡 利用多线程优化, 💡 如何拿到 cpu 个数, UDP, NIO vs BIO vs AIO, stream vs channel, IO 模型, 零拷贝, 传统 IO 问题, NIO 优化, AIO, 文件 AIO, 💡 守护线程, 网络 AIO在中提供了一些关于使用的可以供开发者来读写外部数据和文件我们称这些为是中比较重要知识点且比较难学习的知识点并且随着的发展为提供更好的数据传输性能目前有三种共存分别是和同步阻塞模式全称是一种同步且阻塞的通信模式是一个比较传统的通信方式模式简单使用方便但并发处理能力低通信耗时依赖网速异步非阻塞模型全称是异步非阻塞的是一种非阻塞异步的通信模式在的基础上引入了新的异步通道的概念并提供了异步文件通道和异步套接字通道的实现同步非阻塞模式全称是版以后针对网络传输效能优化的新功能是一种非阻塞同步的通信模式与原来的有同样的作用和目的他们之间最重要的区别是数据打包和传输的方式原来的以流的方式处理数据而以块的方式处理数据面向流的系统一次一个字节地处理数据一个输入流产生一个字节的数据一个输出流消费一个字节的数据面向块的系统以块的形式处理数据每一个操作都在一步中产生或者消费一个数据块按块处理数据比按流式的字节处理数据要快得多但是面向块的缺少一些面向流的所具有的优雅性和简单性三大组件类似于流它是读写数据的双向管道相当于一个内存缓冲区用来暂存读取或写入的数据可以从将数据读入也可以将的数据写入而之前的要么是输入要么是输出比更为底层常见的有用于文件传输用于报文传输用于字节流传输用于服务端字节流传输则用来缓冲读写数据常见的有单从字面意思不好理解需要结合服务器的设计演化来理解它的用途多线程版设计一个管理一个多线程版多线程版缺点内存占用高线程上下文切换成本高只适合连接数少的场景线程池版设计使用线程池让某一个能管理多个但同一时刻只能处理一个线程池版线程池版缺点阻塞模式下线程仅能处理一个连接仅适合短连接场景版设计线程的实现的作用就是配合一个线程来管理多个监听这些上发生的事件这些工作在非阻塞模式下不会让线程吊死在一个上如果一个停滞了但是又监听到另一个的事件就会通知线程处理适合连接数特别多但流量低的场景版调用的会阻塞直到发生了读写就绪事件这些事件发生方法就会返回这些事件交给来处理正确使用姿势向写入数据例如调用调用切换至读模式从读取数据例如调用调用或切换至写模式重复步骤结构有以下重要属性容量当前写入读取位置写入限制读取限制一开始处于写模式写模式下是写入位置等于容量下图表示写入了个字节后的状态切换读模式后切换为读取位置一般是起始位置切换为读取限制一般是切换前写入位置读取个字节后状态清空回到起始位置也切换为写入限制此时处于写模式但如果没有读完的话操作会导致未读数据丢失方法是把未读完的部分向前压缩然后切换至写模式调试工具类打印所有内容打印可读取内容常见方法分配空间可以使用方法为分配空间其它类也有该方法堆内存读写效率低受影响标记复制以及标记整理会导致内存移动直接内存读写效率高少一次拷贝不会受影响但属于系统内存分配效率较慢使用不当可能导致内存泄漏需要合理释放向写入数据有两种办法调用的方法调用自己的方法从读取数据同样有两种办法调用的方法调用自己的方法方法会让读指针向后走如果想重复读取数据可以调用方法将重新置为或者调用方法获取索引的内容它不会移动读指针和是在读取时做一个标记即使改变只要调用就能回到的位置注意和都会清除位置字符串与互转字符串转为字节数组放入将字符串编码为对应容量的并且转换后就是读模式将字节数组包装为对应容量的并且转换后就是读模式将转换为对应的字符串输出的线程安全是非线程安全的分散读分散读取有一个文本文件使用如下方式读取可以将数据填充至多个结果集中写使用如下方式写入可以将多个的数据填充至世界文件内容世界练习网络粘包半包问题网络上有多条数据发送给服务端数据之间使用进行分隔但由于某种原因这些数据在接收时被进行了重新组合例如原始数据有条为变成了下面的两个粘包将多个数据囤积起来发送提高效率半包由于窗口或者缓冲区大小限制无法一次发送太多数据所以延迟到下一次发送现在要求你编写程序将错乱的数据恢复成原始的按分隔的数据网络上有多条数据发送给服务端数据之间使用进行分隔但由于某种原因这些数据在接收时被进行了重新组合例如原始数据有条为变成了下面的两个粘包将多个数据囤积起来发送提高效率半包由于窗口或者缓冲区大小限制无法一次发送太多数据所以延迟到下一次发送现在要求你编写程序将错乱的数据恢复成原始的按分隔的数据遍历到换行符即找到一条完整消息将这条完整消息存入新的分配对应容量的从读向写未读数据向前移动结果文件编程工作模式只能工作在阻塞模式下获取不能直接打开必须通过或者来获取它们都有方法通过获取的只能读通过获取的只能写通过是否能读写根据构造时的读写模式决定读取会从读取数据填充返回值表示读到了多少字节表示到达了文件的末尾写入存入数据切换读模式在中调用是因为方法并不能保证一次将中的内容全部写入关闭必须关闭不过调用了或者的方法会间接地调用的方法位置获取当前位置设置当前位置设置当前位置时如果设置为文件的末尾这时读取会返回这时写入会追加内容但要注意如果超过了文件末尾再写入时在新内容和原末尾之间会有空洞大小使用方法获取文件的大小强制写入操作系统出于性能的考虑会将数据缓存等到关闭后才写入磁盘而不是写一次就立刻写入磁盘可以调用方法将文件内容和元数据文件的权限等信息立刻写入磁盘两个传输数据效率高底层利用操作系统的零拷贝进行优化一次最多传输数据超过数据大小的文件传输效率高底层利用操作系统的零拷贝进行优化一次最多传输数据代表还剩多少字节引入了和类用来表示文件路径是工具类用来获取实例相对路径使用环境变量来定位绝对路径代表了绝对路径同样代表了代表了代表了当前路径代表了上一级路径例如目录结构如下代码正常化路径输出检查文件是否存在创建一级目录如果目录已存在会抛异常不能一次创建多级目录否则会抛异常创建多级目录用拷贝文件如果文件已存在会抛异常如果希望用覆盖掉需要用来控制移动文件保证文件移动的原子性删除文件如果文件不存在会抛异常删除目录如果目录还有内容会抛异常遍历目录文件统计文件数目删除多级目录进入退出拷贝多级目录是目录是普通文件网络编程编程阻塞非阻塞阻塞阻塞模式下相关方法都会导致线程暂停会在没有连接建立时让线程暂停会在没有数据可读时让线程暂停阻塞的表现其实就是线程暂停了暂停期间不会占用但线程相当于闲置单线程下阻塞方法之间相互影响几乎不能正常工作需要多线程支持但多线程下有新的问题体现在以下方面位一个线程位一个线程如果连接数过多必然导致并且线程太多反而会因为频繁上下文切换导致性能降低可以采用线程池技术来减少线程数和线程上下文切换但治标不治本如果有很多连接建立但长时间会阻塞线程池中所有线程因此不适合长连接只适合短连接服务端创建服务器通道绑定监听端口连接集合建立与客户端之间的连接用于客户端与服务器之间通信阻塞方法没有客户端连接线程停滞接收客户端数据阻塞方法等待读取数据没有数据线程停滞客户端非阻塞非阻塞模式下相关方法都不会让线程暂停在在没有连接建立时会返回继续运行在没有数据可读时会返回但线程非阻塞可以去执行其它的或是去执行写数据时线程只是等待数据写入即可无需等通过网络把数据发送出去但非阻塞模式下即使没有连接建立和可读数据线程仍然在不断运行白白浪费了数据复制过程中线程实际还是阻塞的改进的地方服务端创建服务器通道非阻塞模式绑定监听端口连接集合建立与客户端之间的连接用于客户端与服务器之间通信阻塞方法没有客户端连接线程停滞非阻塞没有客户端连接线程继续执行但为非阻塞模式接收客户端数据阻塞方法等待读取数据没有数据线程停滞非阻塞没有读取到数据线程继续执行返回客户端代码不变多路复用单线程可以配合完成对多个可读写事件的监控这称之为多路复用多路复用仅针对网络普通文件没法利用多路复用如果不用的非阻塞模式线程大部分时间都在做无用功而能够保证有可连接事件时才去连接有可读事件才去读取有可写事件才去写入限于网络传输能力未必时时可写一旦可写会触发的可写事件版好处一个线程配合就可以监控多个的事件事件发生线程才去处理避免非阻塞模式下所做无用功让这个线程能够被充分利用节约了线程的数量减少了线程上下文切换创建绑定事件也称之为注册事件绑定的事件才会关心绑定事件必须工作在非阻塞模式没有非阻塞模式因此不能配合一起使用绑定的事件类型可以有客户端连接成功时触发服务器端成功接受连接请求时触发数据可读入时触发有因为接收能力弱数据暂不能读入的情况数据可写出时触发有因为发送能力弱数据暂不能写出的情况监听事件可以通过下面三种方法来监听是否有事件发生方法的返回值代表有多少发生了事件方法阻塞直到绑定事件发生方法阻塞直到绑定事件发生或是超时时间单位为方法不会阻塞也就是不管有没有事件立刻返回自己根据返回值检查是否有事件何时不阻塞事件发生时客户端发起连接请求会触发事件客户端发送数据过来客户端正常异常关闭时都会触发事件另外如果发送的数据大于缓冲区会触发多次读取事件可写会触发事件在下发生时调用调用所在线程处理事件服务端创建管理多个非阻塞模式建立和的联系注册通过定位事件所属的服务端只关注事件方法监听事件没有事件发生线程阻塞有事件线程向下执行之前的事件发生但未处理线程也不会阻塞继续执行处理事件包含所有发生的事件事件发生后要么处理要么取消客户端事件发生后能否不处理事件发生后要么处理要么取消不能什么都不做否则下次该事件仍会触发这是因为底层使用的是水平触发处理事件服务端创建管理多个非阻塞模式建立和的联系注册通过定位事件所属的服务端只关注事件方法监听事件没有事件发生线程阻塞有事件线程向下执行之前的事件发生但未处理线程也不会阻塞继续执行处理事件包含所有发生的事件根据事件类型分别处理触发事件的处理完毕必须将事件移除否则再次遍历时对应的事件已经处理为就会报空指针异常客户端不变开启两个客户端修改一下发送文字输出为何要因为在事件发生后就会将相关的放入集合但不会在处理完后从集合中移除需要我们自己编码删除例如第一次触发了上的事件处理完事件之后将对应的事件移除但并没有移除第二次触发了上的事件但这时中还有上次的在处理时因为没有真正的连上了就会导致空指针异常的作用会取消注册在上的并从集合中删除后续不会再监听事件不处理边界的问题创建管理多个非阻塞模式建立和的联系注册通过定位事件所属的服务端只关注事件方法监听事件没有事件发生线程阻塞有事件线程向下执行之前的事件发生但未处理线程也不会阻塞继续执行处理事件包含所有发生的事件根据事件类型分别处理触发事件的正常断开异常断开取消注册在上的并从集合中删除后续不会再监听事件处理完毕必须将事件移除否则再次遍历时对应的事件已经处理为就会报空指针异常正常输出被拆分中文乱码且被拆分为多个部分处理消息的边界一种思路是固定消息长度数据包大小一样服务器按预定长度读取缺点是浪费带宽即使是比预定长度小的数据也分配预定长度大小另一种思路是按分隔符拆分缺点是效率低格式即类型长度数据类型和长度已知的情况下就可以方便获取消息大小分配合适的缺点是需要提前分配如果内容过大则影响吞吐量是格式是格式客户端服务器发送第一次存入扩容拷贝第二次存入服务端创建管理多个非阻塞模式建立和的联系注册通过定位事件所属的服务端只关注事件方法监听事件没有事件发生线程阻塞有事件线程向下执行之前的事件发生但未处理线程也不会阻塞继续执行处理事件包含所有发生的事件根据事件类型分别处理每个有一个独立的用于传输数据将作为附件关联到对应的上即可获取上的附件触发事件的正常断开由于方法最终会将未读数据向前移动而如果已经读到最大长度即那么此时需要扩容切换读模式新拷贝旧替换绑定的旧异常断开取消注册在上的并从集合中删除后续不会再监听事件处理完毕必须将事件移除否则再次遍历时对应的事件已经处理为就会报空指针异常遍历到换行符即找到一条完整消息将这条完整消息存入新的分配对应容量的从读向写未读数据向前移动客户端阻塞方法等待控制台输入读取输出大小分配每个都需要记录可能被切分的消息因为不能被多个共同使用会造成数据杂乱冲突因此需要为每个维护一个独立的每个有一个独立的用于传输数据将作为附件关联到对应的上即可不能太大比如一个的话要支持百万连接就要内存因此需要设计大小可变的一种思路是首先分配一个较小的例如如果发现数据不够再分配的将内容拷贝至优点是消息连续容易处理缺点是数据拷贝耗费性能参考实现另一种思路是用多个数组组成一个数组不够把多出来的内容写入新的数组与前面的区别是消息存储不连续解析复杂优点是避免了拷贝引起的性能损耗处理事件一次无法写完例子非阻塞模式下由于网络传输能力限制缓冲区写满后无法再写入无法保证把中所有数据都写入因此需要追踪方法的返回值代表实际写入字节数用监听所有的可写事件每个都需要一个来跟踪但这样又会导致占用内存过多就有两阶段策略当消息处理器第一次写入消息时才将注册到上检查上的可写事件如果所有的数据写完了就取消的注册如果不取消每次可写均会触发事件服务端向客户端发送大量数据返回实际写入的字节数第一次写入是否存在剩余内容在原有基础上再关注可写事件绑定剩余内容可写事件中写入没有剩余内容取消绑定无需再关注可写事件客户端接收数据为何要取消只要向发送数据时缓冲可写这个事件会频繁触发相当于长连接因此应当只在缓冲区写不下时再关注可写事件数据写完之后再取消关注更进一步利用多线程优化现在都是多核设计时要充分考虑别让的力量被白白浪费前面的代码只有一个选择器没有充分利用多核如何改进呢分两组选择器单线程配一个选择器专门处理事件创建核心数的线程每个线程配一个选择器轮流处理事件创建固定数量的关联的并关注事件调用初始化启动原子类保证一个持有一个也可以放在构造方法中进行初始化但最好不要在构造方法中写可能抛异常的代码任务队列初始化线程和向队列添加任务通过表达式表示该任务不会立刻执行此时仍在线程唤醒使线程不阻塞即放行第一次用于线程客户端关联的并关注事件执行这里需要注意的是如何保证一个对应一个利用原子类做验证使其在方法中只执行一次原子类保证一个持有一个也可以放在构造方法中进行初始化但最好不要在构造方法中写可能抛异常的代码如何关联的如果一开始就那么在没有事件发生线程阻塞线程也就无法执行需要改变其执行顺序这里利用延迟队列来实现线程间通信并通过唤醒线程任务队列向队列添加任务通过表达式表示该任务不会立刻执行此时仍在线程唤醒使线程不阻塞即放行第一次用于线程客户端关联的并关注事件也可以直接使用唤醒使线程不阻塞即放行第一次用于线程客户端关联的并关注事件如何拿到个数如果工作在容器下因为容器不是物理隔离的会拿到物理个数而不是容器申请时的个数这个问题直到才修复使用参数配置默认开启服务端最终版创建固定数量的关联的并关注事件轮询调用初始化启动原子类保证一个共享同一个也可以放在构造方法中进行初始化但最好不要在构造方法中写可能抛异常的代码任务队列初始化线程和向队列添加任务通过表达式表示该任务不会立刻执行唤醒使线程不阻塞即放行第一次用于线程客户端关联的并关注事件执行服务端客户端不会自动缓冲数据会利用系统提供的发送缓冲区接收缓冲区更为底层仅支持阻塞同时支持阻塞非阻塞网络可配合实现多路复用二者均为全双工即读写可以同时进行模型同步阻塞同步非阻塞同步多路复用异步阻塞没有此情况异步非阻塞同步线程自己去获取结果一个线程异步线程自己不去获取结果而是由其它线程送结果至少两个线程当调用一次或后会切换至操作系统内核态来完成真正数据读取而读取又分为两个阶段分别为等待数据阶段复制数据阶段阻塞非阻塞多路复用异步阻塞多路复用零拷贝传统问题传统的将一个文件通过写出内部工作流程是这样的本身并不具备读写能力因此方法调用后要从程序的用户态切换至内核态去调用操作系统的读能力将数据读入内核缓冲区这期间用户线程阻塞操作系统使用来实现文件读其间也不会使用也可以理解为硬件单元用来解放完成文件从内核态切换回用户态将数据从内核缓冲区读入用户缓冲区即这期间会参与拷贝无法利用调用方法这时将数据从用户缓冲区写入缓冲区会参与拷贝接下来要向网卡写数据这项能力又不具备因此又得从用户态切换至内核态调用操作系统的写能力使用将缓冲区的数据写入网卡不会使用可以看到中间环节较多的实际不是物理设备级别的读写而是缓存的复制底层的真正读写是操作系统来完成的用户态与内核态的切换发生了次这个操作比较重量级数据拷贝了共次优化通过使用的还是内存使用的是操作系统内存大部分步骤与优化前相同不再赘述唯有一点可以使用将堆外内存映射到内存中来直接访问使用这块内存不受垃圾回收的影响因此内存地址固定有助于读写中的对象仅维护了此内存的虚引用内存回收分成两步对象被垃圾回收将虚引用加入引用队列通过专门线程访问引用队列根据虚引用释放堆外内存减少了一次数据拷贝用户态与内核态的切换次数没有减少进一步优化底层采用了后提供的方法中对应着两个调用方法拷贝数据调用方法后要从程序的用户态切换至内核态使用将数据读入内核缓冲区不会使用数据从内核缓冲区传输到缓冲区会参与拷贝最后使用将缓冲区的数据写入网卡不会使用可以看到只发生了一次用户态与内核态的切换数据拷贝了次进一步优化调用方法后要从程序的用户态切换至内核态使用将数据读入内核缓冲区不会使用只会将一些和信息拷入缓冲区几乎无消耗使用将内核缓冲区的数据写入网卡不会使用整个过程仅只发生了一次用户态与内核态的切换数据拷贝了次所谓的零拷贝并不是真正无拷贝而是不会拷贝重复数据到内存中零拷贝的优点有更少的用户态与内核态的切换不利用计算减少缓存伪共享零拷贝适合小文件传输用来解决数据复制阶段的阻塞问题同步意味着在进行读写操作时线程需要等待结果还是相当于闲置异步意味着在进行读写操作时线程不必等待结果而是将来由操作系统来通过回调方式由另外的线程来获得结果异步模型需要底层操作系统提供支持系统通过实现了真正的异步系统异步在版本引入但其底层实现还是用多路复用模拟了异步性能没有优势文件先来看看输出可以看到响应文件读取成功的是另一个线程主线程并没有操作阻塞守护线程默认文件使用的线程都是守护线程所以最后要执行以避免守护线程意外结束网络处理完第一个时需要再次调用方法来处理下一个事件如果作为附件的还有内容需要再次写出剩余内容读事件由处理写事件由处理处理完第一个时需要再次调用方法来处理下一个事件',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-09-15 09:52:00',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 8 || hour >= 21
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><!-- hexo injector head_end start --><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://blog-1314261683.cos.ap-chengdu.myqcloud.com/public/avatar2.png"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><a id="site-name" href="/" accesskey="h"><div class="title">「hirikiのblog」</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 归档</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/photos/"><span> 相册</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/comments/"><span> 留言</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/about/"><span> 关于</span></a></div></div></div><div id="nav-right"><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><div class="nav-button" id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" title="搜索🔍" accesskey="s"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span> 搜索</span></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" target="_blank"><img class="post-qr-code-img" alt="微信" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" target="_blank"><img class="post-qr-code-img" alt="支付宝" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/API%E7%BD%91%E5%85%B3/" style="font-size: 1.05rem;">API网关<sup>29</sup></a><a href="/tags/DDD/" style="font-size: 1.05rem;">DDD<sup>1</sup></a><a href="/tags/Docker/" style="font-size: 1.05rem;">Docker<sup>1</sup></a><a href="/tags/HashMap/" style="font-size: 1.05rem;">HashMap<sup>2</sup></a><a href="/tags/JWT/" style="font-size: 1.05rem;">JWT<sup>1</sup></a><a href="/tags/LVS/" style="font-size: 1.05rem;">LVS<sup>1</sup></a><a href="/tags/MIT-6-824/" style="font-size: 1.05rem;">MIT 6.824<sup>2</sup></a><a href="/tags/MapReduce/" style="font-size: 1.05rem;">MapReduce<sup>1</sup></a><a href="/tags/NIO/" style="font-size: 1.05rem;">NIO<sup>1</sup></a><a href="/tags/Netty/" style="font-size: 1.05rem;">Netty<sup>5</sup></a><a href="/tags/Nginx/" style="font-size: 1.05rem;">Nginx<sup>3</sup></a><a href="/tags/Redis%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85/" style="font-size: 1.05rem;">Redis发布订阅<sup>1</sup></a><a href="/tags/Shiro/" style="font-size: 1.05rem;">Shiro<sup>1</sup></a><a href="/tags/SpringBoot-Starter/" style="font-size: 1.05rem;">SpringBoot Starter<sup>1</sup></a><a href="/tags/SpringBoot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D/" style="font-size: 1.05rem;">SpringBoot自动装配<sup>1</sup></a><a href="/tags/docker/" style="font-size: 1.05rem;">docker<sup>3</sup></a><a href="/tags/etcd/" style="font-size: 1.05rem;">etcd<sup>1</sup></a><a href="/tags/kafka/" style="font-size: 1.05rem;">kafka<sup>1</sup></a><a href="/tags/zookeeper/" style="font-size: 1.05rem;">zookeeper<sup>1</sup></a><a href="/tags/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/" style="font-size: 1.05rem;">动态代理<sup>1</sup></a><a href="/tags/%E5%90%AF%E5%8A%A8%E5%BC%95%E6%93%8E/" style="font-size: 1.05rem;">启动引擎<sup>1</sup></a><a href="/tags/%E5%AE%B9%E5%99%A8%E4%B8%8A%E4%B8%8B%E6%96%87/" style="font-size: 1.05rem;">容器上下文<sup>1</sup></a><a href="/tags/%E5%BA%93%E8%A1%A8%E8%AE%BE%E8%AE%A1/" style="font-size: 1.05rem;">库表设计<sup>1</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E6%BA%90%E6%8A%BD%E8%B1%A1/" style="font-size: 1.05rem;">数据源抽象<sup>1</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 1.05rem;">数据结构<sup>1</sup></a><a href="/tags/%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/" style="font-size: 1.05rem;">服务发现<sup>8</sup></a><a href="/tags/%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C/" style="font-size: 1.05rem;">服务注册<sup>2</sup></a><a href="/tags/%E6%A0%91/" style="font-size: 1.05rem;">树<sup>1</sup></a><a href="/tags/%E6%B3%9B%E5%8C%96%E8%B0%83%E7%94%A8/" style="font-size: 1.05rem;">泛化调用<sup>1</sup></a><a href="/tags/%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/" style="font-size: 1.05rem;">注册中心<sup>5</sup></a><a href="/tags/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/" style="font-size: 1.05rem;">负载均衡<sup>1</sup></a><a href="/tags/%E8%B7%A8%E5%9F%9F/" style="font-size: 1.05rem;">跨域<sup>1</sup></a><a href="/tags/%E8%BF%90%E8%90%A5%E5%90%8E%E5%8F%B0/" style="font-size: 1.05rem;">运营后台<sup>2</sup></a><a href="/tags/%E9%80%9A%E4%BF%A1%E7%BB%84%E4%BB%B6/" style="font-size: 1.05rem;">通信组件<sup>9</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span><a class="card-more-btn" href="/archives/" title="查看更多">
    <i class="anzhiyufont anzhiyu-icon-angle-right"></i></a></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/04/"><span class="card-archive-list-date">四月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/02/"><span class="card-archive-list-date">二月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/12/"><span class="card-archive-list-date">十二月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/10/"><span class="card-archive-list-date">十月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/09/"><span class="card-archive-list-date">九月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/07/"><span class="card-archive-list-date">七月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/06/"><span class="card-archive-list-date">六月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">7</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/05/"><span class="card-archive-list-date">五月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">24</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java/" itemprop="url">Java</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/NIO/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>NIO</span></a></span></div></div><h1 class="post-title" itemprop="name headline">NIO基础</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2023-04-09T07:46:00.000Z" title="发表于 2023-04-09 15:46:00">2023-04-09</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2023-09-15T01:52:00.000Z" title="更新于 2023-09-15 09:52:00">2023-09-15</time></span></div><div class="meta-secondline"><span class="post-meta-separator"></span><span class="post-meta-pv-cv" id="" data-flag-title="NIO基础"><i class="anzhiyufont anzhiyu-icon-fw-eye post-meta-icon"></i><span class="post-meta-label" title="阅读量">阅读量:</span><span id="busuanzi_value_page_pv"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-spin"></i></span></span><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为重庆"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>重庆</span><span class="post-meta-separator"></span><span class="post-meta-commentcount"><i class="anzhiyufont anzhiyu-icon-comments post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/posts/e5d14cce.html#post-comment" tabindex="-1"><span id="twikoo-count"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-spin"></i></span></a></span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src="https://blog-1314261683.cos.ap-chengdu.myqcloud.com/public/四月.jpeg"></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="http://www.sherry.zone/posts/e5d14cce.html"><header><a class="post-meta-categories" href="/categories/Java/" itemprop="url">Java</a><a href="/tags/NIO/" tabindex="-1" itemprop="url">NIO</a><h1 id="CrawlerTitle" itemprop="name headline">NIO基础</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">hiriki</span><time itemprop="dateCreated datePublished" datetime="2023-04-09T07:46:00.000Z" title="发表于 2023-04-09 15:46:00">2023-04-09</time><time itemprop="dateCreated datePublished" datetime="2023-09-15T01:52:00.000Z" title="更新于 2023-09-15 09:52:00">2023-09-15</time></header><p>在Java中，提供了一些关于使用IO的API，可以供开发者来读写外部数据和文件，我们称这些API为Java IO。IO是Java中比较重要知识点，且比较难学习的知识点。并且随着Java的发展为提供更好的数据传输性能，目前有三种IO共存；分别是BIO、NIO和AIO。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://blog-1314261683.cos.ap-chengdu.myqcloud.com/image/Netty/BNAIO.png" alt="BNAIO"></p>
<p><strong>Java BIO[Blocking I/O] | 同步阻塞I/O模式</strong></p>
<p>BIO 全称 Block-IO ，是一种同步且阻塞的通信模式。是一个比较传统的通信方式，模式简单，使用方便。但并发处理能力低，通信耗时，依赖网速。</p>
<p><strong>Java AIO[Asynchronous I/O] | 异步非阻塞I/O模型</strong></p>
<p>Java AIO，全称 Asynchronous IO，是异步非阻塞的IO。是一种非阻塞异步的通信模式。在NIO的基础上引入了新的异步通道的概念，并提供了异步文件通道和异步套接字通道的实现。</p>
<p><strong>Java NIO[Non Blocking I/O] | 同步非阻塞模式</strong></p>
<ul>
<li>Java NIO，全称 Non-Block IO ，是Java SE 1.4版以后，针对网络传输效能优化的新功能。是一种非阻塞同步的通信模式。</li>
<li>NIO 与原来的 I/O 有同样的作用和目的, 他们之间最重要的区别是数据打包和传输的方式。原来的 I/O 以流的方式处理数据，而 NIO 以块的方式处理数据。</li>
<li>面向流的 I/O 系统一次一个字节地处理数据。一个输入流产生一个字节的数据，一个输出流消费一个字节的数据。</li>
<li>面向块的 I/O 系统以块的形式处理数据。每一个操作都在一步中产生或者消费一个数据块。按块处理数据比按(流式的)字节处理数据要快得多。但是面向块的 I/O - 缺少一些面向流的 I/O 所具有的优雅性和简单性。</li>
</ul>
<h1 id="NIO-三大组件"><a href="#NIO-三大组件" class="headerlink" title="NIO 三大组件"></a>NIO 三大组件</h1><h2 id="Channel-amp-Buffer"><a href="#Channel-amp-Buffer" class="headerlink" title="Channel &amp; Buffer"></a>Channel &amp; Buffer</h2><p>Channel 类似于 stream 流，它是读写数据的双向管道，Buffer 相当于一个内存缓冲区，用来暂存 读取或写入 Channel 的数据。可以从 channel 将数据读入 buffer，也可以将 buffer 的数据写入 channel，而之前的 stream 要么是输入，要么是输出，channel 比 stream 更为底层。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">channel --&gt; buffer</span><br><span class="line">buffer --&gt; channel</span><br></pre></td></tr></table></figure>
<p>常见的 Channel 有</p>
<ul>
<li>FileChannel        用于文件传输</li>
<li>DatagramChannel    用于 UDP 报文传输</li>
<li>SocketChannel        用于 TCP 字节流传输</li>
<li>ServerSocketChannel    用于 TCP 服务端字节流传输</li>
</ul>
<p>buffer 则用来缓冲读写数据，常见的 buffer 有</p>
<ul>
<li><p>ByteBuffer</p>
</li>
<li><ul>
<li>MappedByteBuffer</li>
<li>DirectByteBuffer</li>
<li>HeapByteBuffer</li>
</ul>
</li>
<li><p>ShortBuffer</p>
</li>
<li>IntBuffer</li>
<li>LongBuffer</li>
<li>FloatBuffer</li>
<li>DoubleBuffer</li>
<li>CharBuffer</li>
</ul>
<h2 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h2><p>selector 单从字面意思不好理解，需要结合服务器的设计演化来理解它的用途</p>
<h3 id="多线程版设计"><a href="#多线程版设计" class="headerlink" title="多线程版设计"></a>多线程版设计</h3><p>一个 thread 管理一个 socket。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">subgraph 多线程版</span><br><span class="line">t1(thread1) --&gt; s1(socket1)</span><br><span class="line">t2(thread2) --&gt; s2(socket2)</span><br><span class="line">t3(thread3) --&gt; s3(socket3)</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<h4 id="⚠️-多线程版缺点"><a href="#⚠️-多线程版缺点" class="headerlink" title="⚠️ 多线程版缺点"></a>⚠️ 多线程版缺点</h4><ul>
<li>内存占用高</li>
<li>线程上下文切换成本高</li>
<li>只适合连接数少的场景</li>
</ul>
<h3 id="线程池版设计"><a href="#线程池版设计" class="headerlink" title="线程池版设计"></a>线程池版设计</h3><p>使用线程池让 某一个 thread 能管理多个 socket ，但同一时刻只能处理一个 socket 。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">subgraph 线程池版</span><br><span class="line">t4(thread1) --&gt; s4(socket1)</span><br><span class="line">t5(thread2) --&gt; s5(socket2)</span><br><span class="line">t4(thread1) -.-&gt; s6(socket3)</span><br><span class="line">t5(thread2) -.-&gt; s7(socket4)</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<h4 id="⚠️-线程池版缺点"><a href="#⚠️-线程池版缺点" class="headerlink" title="⚠️ 线程池版缺点"></a>⚠️ 线程池版缺点</h4><ul>
<li>阻塞模式下，线程仅能处理一个 socket 连接</li>
<li>仅适合短连接场景</li>
</ul>
<h3 id="selector-版设计-线程的实现"><a href="#selector-版设计-线程的实现" class="headerlink" title="selector 版设计 线程的实现"></a>selector 版设计 <a target="_blank" rel="noopener" href="https://xiaolincoding.com/os/4_process/process_base.html#线程的实现">线程的实现</a></h3><p>selector 的作用就是配合一个线程来管理多个 channel，监听这些 channel 上发生的事件，这些 channel 工作在非阻塞模式下，不会让线程吊死在一个 channel 上。<strong>如果一个 channel 停滞了，但是 seletor 又监听到另一个 channel 的事件，就会通知线程处理。</strong></p>
<p>适合连接数特别多，但流量低的场景（low traffic）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">subgraph selector 版</span><br><span class="line">thread --&gt; selector</span><br><span class="line">selector --&gt; c1(channel)</span><br><span class="line">selector --&gt; c2(channel)</span><br><span class="line">selector --&gt; c3(channel)</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>调用 selector 的 select() 会阻塞直到 channel 发生了读写就绪事件，这些事件发生，select 方法就会返回这些事件交给 thread 来处理。</p>
<h1 id="ByteBuffer"><a href="#ByteBuffer" class="headerlink" title="ByteBuffer"></a>ByteBuffer</h1><h2 id="ByteBuffer-正确使用姿势"><a href="#ByteBuffer-正确使用姿势" class="headerlink" title="ByteBuffer 正确使用姿势"></a>ByteBuffer 正确使用姿势</h2><ol>
<li>向 buffer 写入数据，例如调用 channel.read(buffer)</li>
<li>调用 flip() 切换至<strong>读模式</strong></li>
<li>从 buffer 读取数据，例如调用 buffer.get()</li>
<li>调用 clear() 或 compact() 切换至<strong>写模式</strong></li>
<li>重复 1~4 步骤</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://blog-1314261683.cos.ap-chengdu.myqcloud.com/image/Netty/ByteBuffer1.png" alt="ByteBuffer1"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://blog-1314261683.cos.ap-chengdu.myqcloud.com/image/Netty/ByteBuffer2.png" alt="ByteBuffer2"></p>
<h2 id="ByteBuffer-结构"><a href="#ByteBuffer-结构" class="headerlink" title="ByteBuffer 结构"></a>ByteBuffer 结构</h2><p>ByteBuffer 有以下重要属性</p>
<ul>
<li>capacity    容量</li>
<li>position    当前写入/读取位置</li>
<li>limit        写入限制/读取限制</li>
</ul>
<p>一开始，处于写模式</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://blog-1314261683.cos.ap-chengdu.myqcloud.com/image/Netty/ByteBuffer3.png" alt="ByteBuffer3"></p>
<p>写模式下，position 是写入位置，limit 等于容量，下图表示写入了 4 个字节后的状态</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://blog-1314261683.cos.ap-chengdu.myqcloud.com/image/Netty/ByteBuffer4.png" alt="ByteBuffer4"></p>
<p>flip 切换读模式后，position 切换为读取位置，一般是起始位置，limit 切换为读取限制，一般是切换前 position 写入位置</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://blog-1314261683.cos.ap-chengdu.myqcloud.com/image/Netty/ByteBuffer5.png" alt="ByteBuffer5"></p>
<p>读取 4 个字节后，状态</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://blog-1314261683.cos.ap-chengdu.myqcloud.com/image/Netty/ByteBuffer6.png" alt="ByteBuffer6"></p>
<p>clear 清空 buffer，postion 回到起始位置，limit 也切换为写入限制，此时 buffer 处于写模式</p>
<p><strong>但如果 buffer 没有读完的话，clear 操作会导致未读数据丢失</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://blog-1314261683.cos.ap-chengdu.myqcloud.com/image/Netty/ByteBuffer7.png" alt="ByteBuffer7"></p>
<p>compact 方法，是把未读完的部分向前压缩，然后切换至写模式</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://blog-1314261683.cos.ap-chengdu.myqcloud.com/image/Netty/ByteBuffer8.png" alt="ByteBuffer8"></p>
<h3 id="💡-调试工具类"><a href="#💡-调试工具类" class="headerlink" title="💡 调试工具类"></a>💡 调试工具类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> io.netty.util.internal.MathUtil.isOutOfBounds;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> io.netty.util.internal.StringUtil.NEWLINE;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Ray</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2023/4/22 23:01</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ByteBufferUtil</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">char</span>[] BYTE2CHAR = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">char</span>[] HEXDUMP_TABLE = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">256</span> * <span class="number">4</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] HEXPADDING = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">16</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] HEXDUMP_ROWPREFIXES = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">65536</span> &gt;&gt;&gt; <span class="number">4</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] BYTE2HEX = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] BYTEPADDING = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">16</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">char</span>[] DIGITS = <span class="string">&quot;0123456789abcdef&quot;</span>.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">256</span>; i++) &#123;</span><br><span class="line">            HEXDUMP_TABLE[i &lt;&lt; <span class="number">1</span>] = DIGITS[i &gt;&gt;&gt; <span class="number">4</span> &amp; <span class="number">0x0F</span>];</span><br><span class="line">            HEXDUMP_TABLE[(i &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>] = DIGITS[i &amp; <span class="number">0x0F</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Generate the lookup table for hex dump paddings</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; HEXPADDING.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">padding</span> <span class="operator">=</span> HEXPADDING.length - i;</span><br><span class="line">            <span class="type">StringBuilder</span> <span class="variable">buf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(padding * <span class="number">3</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; padding; j++) &#123;</span><br><span class="line">                buf.append(<span class="string">&quot;   &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            HEXPADDING[i] = buf.toString();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Generate the lookup table for the start-offset header in each row (up to 64KiB).</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; HEXDUMP_ROWPREFIXES.length; i++) &#123;</span><br><span class="line">            <span class="type">StringBuilder</span> <span class="variable">buf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="number">12</span>);</span><br><span class="line">            buf.append(NEWLINE);</span><br><span class="line">            buf.append(Long.toHexString(i &lt;&lt; <span class="number">4</span> &amp; <span class="number">0xFFFFFFFFL</span> | <span class="number">0x100000000L</span>));</span><br><span class="line">            buf.setCharAt(buf.length() - <span class="number">9</span>, <span class="string">&#x27;|&#x27;</span>);</span><br><span class="line">            buf.append(<span class="string">&#x27;|&#x27;</span>);</span><br><span class="line">            HEXDUMP_ROWPREFIXES[i] = buf.toString();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Generate the lookup table for byte-to-hex-dump conversion</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; BYTE2HEX.length; i++) &#123;</span><br><span class="line">            BYTE2HEX[i] = <span class="string">&#x27; &#x27;</span> + StringUtil.byteToHexStringPadded(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Generate the lookup table for byte dump paddings</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; BYTEPADDING.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">padding</span> <span class="operator">=</span> BYTEPADDING.length - i;</span><br><span class="line">            <span class="type">StringBuilder</span> <span class="variable">buf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(padding);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; padding; j++) &#123;</span><br><span class="line">                buf.append(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            BYTEPADDING[i] = buf.toString();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Generate the lookup table for byte-to-char conversion</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; BYTE2CHAR.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt;= <span class="number">0x1f</span> || i &gt;= <span class="number">0x7f</span>) &#123;</span><br><span class="line">                BYTE2CHAR[i] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                BYTE2CHAR[i] = (<span class="type">char</span>) i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 打印所有内容</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> buffer</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">debugAll</span><span class="params">(ByteBuffer buffer)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">oldlimit</span> <span class="operator">=</span> buffer.limit();</span><br><span class="line">        buffer.limit(buffer.capacity());</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">origin</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="number">256</span>);</span><br><span class="line">        appendPrettyHexDump(origin, buffer, <span class="number">0</span>, buffer.capacity());</span><br><span class="line">        System.out.println(<span class="string">&quot;+--------+-------------------- all ------------------------+----------------+&quot;</span>);</span><br><span class="line">        System.out.printf(<span class="string">&quot;position: [%d], limit: [%d]\n&quot;</span>, buffer.position(), oldlimit);</span><br><span class="line">        System.out.println(origin);</span><br><span class="line">        System.out.println();</span><br><span class="line">        buffer.limit(oldlimit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 打印可读取内容</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> buffer</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">debugRead</span><span class="params">(ByteBuffer buffer)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="number">256</span>);</span><br><span class="line">        appendPrettyHexDump(builder, buffer, buffer.position(), buffer.limit() - buffer.position());</span><br><span class="line">        System.out.println(<span class="string">&quot;+--------+-------------------- read -----------------------+----------------+&quot;</span>);</span><br><span class="line">        System.out.printf(<span class="string">&quot;position: [%d], limit: [%d]\n&quot;</span>, buffer.position(), buffer.limit());</span><br><span class="line">        System.out.println(builder);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">appendPrettyHexDump</span><span class="params">(StringBuilder dump, ByteBuffer buf, <span class="type">int</span> offset, <span class="type">int</span> length)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isOutOfBounds(offset, length, buf.capacity())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(</span><br><span class="line">                    <span class="string">&quot;expected: &quot;</span> + <span class="string">&quot;0 &lt;= offset(&quot;</span> + offset + <span class="string">&quot;) &lt;= offset + length(&quot;</span> + length</span><br><span class="line">                            + <span class="string">&quot;) &lt;= &quot;</span> + <span class="string">&quot;buf.capacity(&quot;</span> + buf.capacity() + <span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dump.append(</span><br><span class="line">                <span class="string">&quot;         +-------------------------------------------------+&quot;</span> +</span><br><span class="line">                        NEWLINE + <span class="string">&quot;         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |&quot;</span> +</span><br><span class="line">                        NEWLINE + <span class="string">&quot;+--------+-------------------------------------------------+----------------+&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">startIndex</span> <span class="operator">=</span> offset;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">fullRows</span> <span class="operator">=</span> length &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">remainder</span> <span class="operator">=</span> length &amp; <span class="number">0xF</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Dump the rows which have 16 bytes.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> <span class="number">0</span>; row &lt; fullRows; row++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">rowStartIndex</span> <span class="operator">=</span> (row &lt;&lt; <span class="number">4</span>) + startIndex;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Per-row prefix.</span></span><br><span class="line">            appendHexDumpRowPrefix(dump, row, rowStartIndex);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Hex dump</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">rowEndIndex</span> <span class="operator">=</span> rowStartIndex + <span class="number">16</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> rowStartIndex; j &lt; rowEndIndex; j++) &#123;</span><br><span class="line">                dump.append(BYTE2HEX[getUnsignedByte(buf, j)]);</span><br><span class="line">            &#125;</span><br><span class="line">            dump.append(<span class="string">&quot; |&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// ASCII dump</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> rowStartIndex; j &lt; rowEndIndex; j++) &#123;</span><br><span class="line">                dump.append(BYTE2CHAR[getUnsignedByte(buf, j)]);</span><br><span class="line">            &#125;</span><br><span class="line">            dump.append(<span class="string">&#x27;|&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Dump the last row which has less than 16 bytes.</span></span><br><span class="line">        <span class="keyword">if</span> (remainder != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">rowStartIndex</span> <span class="operator">=</span> (fullRows &lt;&lt; <span class="number">4</span>) + startIndex;</span><br><span class="line">            appendHexDumpRowPrefix(dump, fullRows, rowStartIndex);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Hex dump</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">rowEndIndex</span> <span class="operator">=</span> rowStartIndex + remainder;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> rowStartIndex; j &lt; rowEndIndex; j++) &#123;</span><br><span class="line">                dump.append(BYTE2HEX[getUnsignedByte(buf, j)]);</span><br><span class="line">            &#125;</span><br><span class="line">            dump.append(HEXPADDING[remainder]);</span><br><span class="line">            dump.append(<span class="string">&quot; |&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Ascii dump</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> rowStartIndex; j &lt; rowEndIndex; j++) &#123;</span><br><span class="line">                dump.append(BYTE2CHAR[getUnsignedByte(buf, j)]);</span><br><span class="line">            &#125;</span><br><span class="line">            dump.append(BYTEPADDING[remainder]);</span><br><span class="line">            dump.append(<span class="string">&#x27;|&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dump.append(NEWLINE +</span><br><span class="line">                <span class="string">&quot;+--------+-------------------------------------------------+----------------+&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">appendHexDumpRowPrefix</span><span class="params">(StringBuilder dump, <span class="type">int</span> row, <span class="type">int</span> rowStartIndex)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (row &lt; HEXDUMP_ROWPREFIXES.length) &#123;</span><br><span class="line">            dump.append(HEXDUMP_ROWPREFIXES[row]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dump.append(NEWLINE);</span><br><span class="line">            dump.append(Long.toHexString(rowStartIndex &amp; <span class="number">0xFFFFFFFFL</span> | <span class="number">0x100000000L</span>));</span><br><span class="line">            dump.setCharAt(dump.length() - <span class="number">9</span>, <span class="string">&#x27;|&#x27;</span>);</span><br><span class="line">            dump.append(<span class="string">&#x27;|&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">short</span> <span class="title function_">getUnsignedByte</span><span class="params">(ByteBuffer buffer, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">short</span>) (buffer.get(index) &amp; <span class="number">0xFF</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ByteBuffer-常见方法"><a href="#ByteBuffer-常见方法" class="headerlink" title="ByteBuffer 常见方法"></a>ByteBuffer 常见方法</h2><h3 id="分配空间"><a href="#分配空间" class="headerlink" title="分配空间"></a>分配空间</h3><p>可以使用 allocate 方法为 ByteBuffer 分配空间，其它 buffer 类也有该方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestByteBufferAllocate</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(ByteBuffer.allocate(<span class="number">10</span>).getClass());</span><br><span class="line">        System.out.println(ByteBuffer.allocateDirect(<span class="number">10</span>).getClass());</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        class java.nio.HeapByteBuffer</span></span><br><span class="line"><span class="comment">        - Java堆内存,读写效率低，受 GC 影响，标记-复制以及标记-整理会导致内存移动</span></span><br><span class="line"><span class="comment">        class java.nio.DirectByteBuffer</span></span><br><span class="line"><span class="comment">        - 直接内存,读写效率高(少一次拷贝),不会受 GC 影响,但属于系统内存,分配效率较慢,使用不当可能导致 OOM 内存泄漏,需要合理释放</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="向-buffer-写入数据"><a href="#向-buffer-写入数据" class="headerlink" title="向 buffer 写入数据"></a>向 buffer 写入数据</h3><p>有两种办法</p>
<ul>
<li>调用 channel 的 read 方法</li>
<li>调用 buffer 自己的 put 方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">readBytes</span> <span class="operator">=</span> channel.read(buf);</span><br><span class="line">buf.put((<span class="type">byte</span>)<span class="number">127</span>);</span><br></pre></td></tr></table></figure>
<h3 id="从-buffer-读取数据"><a href="#从-buffer-读取数据" class="headerlink" title="从 buffer 读取数据"></a>从 buffer 读取数据</h3><p>同样有两种办法</p>
<ul>
<li>调用 channel 的 write 方法</li>
<li>调用 buffer 自己的 get 方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">writeBytes</span> <span class="operator">=</span> channel.write(buf);</span><br><span class="line"><span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> buf.get();</span><br></pre></td></tr></table></figure>
<p>get 方法会让 position 读指针向后走，如果想重复读取数据</p>
<ul>
<li>可以调用 rewind 方法将 position 重新置为 0</li>
<li>或者调用 get(int i) 方法获取索引 i 的内容，它不会移动读指针</li>
</ul>
<h4 id="mark-和-reset"><a href="#mark-和-reset" class="headerlink" title="mark 和 reset"></a>mark 和 reset</h4><p>mark 是在读取时，做一个标记，即使 position 改变，只要调用 reset 就能回到 mark 的位置</p>
<p><strong>注意</strong></p>
<p>rewind 和 flip 都会清除 mark 位置</p>
<h3 id="字符串与-ByteBuffer-互转"><a href="#字符串与-ByteBuffer-互转" class="headerlink" title="字符串与 ByteBuffer 互转"></a>字符串与 ByteBuffer 互转</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Ray</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2023/4/23 00:08</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestByteBufferString</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 字符串转为 字节数组 放入 ByteBuffer</span></span><br><span class="line">        ByteBuffer byteBuffer= ByteBuffer.allocate(<span class="number">16</span>);</span><br><span class="line">        byteBuffer.put(<span class="string">&quot;hello&quot;</span>.getBytes());</span><br><span class="line">        debugAll(byteBuffer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. Charset 将字符串编码为对应容量的 ByteBuffer,并且转换后就是读模式</span></span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">charsetBuffer</span> <span class="operator">=</span> StandardCharsets.UTF_8.encode(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        <span class="comment">// ByteBuffer charsetBuffer = Charset.forName(&quot;UTF-8&quot;).encode(&quot;hello&quot;);</span></span><br><span class="line">        debugAll(charsetBuffer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. wrap 将字节数组包装为对应容量的 ByteBuffer,并且转换后就是读模式</span></span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">wrapBuffer</span> <span class="operator">=</span> ByteBuffer.wrap(<span class="string">&quot;hello&quot;</span>.getBytes());</span><br><span class="line">        debugAll(wrapBuffer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将 ByteBuffer 转换为对应的字符串</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> StandardCharsets.UTF_8.decode(charsetBuffer).toString();</span><br><span class="line">        System.out.println(str1);</span><br><span class="line"></span><br><span class="line">        byteBuffer.flip();</span><br><span class="line">        <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> StandardCharsets.UTF_8.decode(byteBuffer).toString();</span><br><span class="line">        System.out.println(str2);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">+--------+-------------------- all ------------------------+----------------+</span><br><span class="line">position: [5], <span class="built_in">limit</span>: [16]</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 68 65 6c 6c 6f 00 00 00 00 00 00 00 00 00 00 00 |hello...........|</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line"></span><br><span class="line">+--------+-------------------- all ------------------------+----------------+</span><br><span class="line">position: [0], <span class="built_in">limit</span>: [5]</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 68 65 6c 6c 6f                                  |hello           |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line"></span><br><span class="line">+--------+-------------------- all ------------------------+----------------+</span><br><span class="line">position: [0], <span class="built_in">limit</span>: [5]</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 68 65 6c 6c 6f                                  |hello           |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line"></span><br><span class="line">hello</span><br><span class="line">hello</span><br></pre></td></tr></table></figure>
<h3 id="⚠️-Buffer-的线程安全"><a href="#⚠️-Buffer-的线程安全" class="headerlink" title="⚠️ Buffer 的线程安全"></a>⚠️ Buffer 的线程安全</h3><p>Buffer 是<strong>非线程安全的</strong></p>
<h3 id="Scattering-Reads-分散读"><a href="#Scattering-Reads-分散读" class="headerlink" title="Scattering Reads 分散读"></a>Scattering Reads 分散读</h3><p>分散读取，有一个文本文件 words.txt</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">onetwothree</span><br></pre></td></tr></table></figure>
<p>使用如下方式读取，可以将数据填充至多个 buffer</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestScatteringReads</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">FileChannel</span> <span class="variable">channel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="string">&quot;demo-02/words.txt&quot;</span>, <span class="string">&quot;r&quot;</span>).getChannel()) &#123;</span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">buffer1</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">3</span>);</span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">buffer2</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">3</span>);</span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">buffer3</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">5</span>);</span><br><span class="line">            channel.read(<span class="keyword">new</span> <span class="title class_">ByteBuffer</span>[]&#123;buffer1,buffer2,buffer3&#125;);</span><br><span class="line">            buffer1.flip();</span><br><span class="line">            buffer2.flip();</span><br><span class="line">            buffer3.flip();</span><br><span class="line">            debugAll(buffer1);</span><br><span class="line">            debugAll(buffer2);</span><br><span class="line">            debugAll(buffer3);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">+--------+-------------------- all ------------------------+----------------+</span><br><span class="line">position: [0], <span class="built_in">limit</span>: [3]</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 6f 6e 65                                        |one             |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line"></span><br><span class="line">+--------+-------------------- all ------------------------+----------------+</span><br><span class="line">position: [0], <span class="built_in">limit</span>: [3]</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 74 77 6f                                        |two             |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line"></span><br><span class="line">+--------+-------------------- all ------------------------+----------------+</span><br><span class="line">position: [0], <span class="built_in">limit</span>: [5]</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 74 68 72 65 65                                  |three           |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure>
<h3 id="Gathering-Writes-集中写"><a href="#Gathering-Writes-集中写" class="headerlink" title="Gathering Writes 集中写"></a>Gathering Writes 集中写</h3><p>使用如下方式写入，可以将多个 buffer 的数据填充至 channel</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestGatheringWrites</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">buffer1</span> <span class="operator">=</span> StandardCharsets.UTF_8.encode(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">buffer2</span> <span class="operator">=</span> StandardCharsets.UTF_8.encode(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">buffer3</span> <span class="operator">=</span> StandardCharsets.UTF_8.encode(<span class="string">&quot;世界&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">FileChannel</span> <span class="variable">channel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="string">&quot;demo-02/words.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>).getChannel()) &#123;</span><br><span class="line">            channel.position(<span class="number">11</span>);</span><br><span class="line">            channel.write(<span class="keyword">new</span> <span class="title class_">ByteBuffer</span>[]&#123;buffer1,buffer2,buffer3&#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>文件内容</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">onetwothreehelloworld世界</span><br></pre></td></tr></table></figure>
<h3 id="练习：网络粘包半包问题"><a href="#练习：网络粘包半包问题" class="headerlink" title="练习：网络粘包半包问题"></a>练习：网络粘包半包问题</h3><p>网络上有多条数据发送给服务端，数据之间使用 \n 进行分隔<br>但由于某种原因这些数据在接收时，被进行了重新组合，例如原始数据有3条为</p>
<ul>
<li>Hello,world\n</li>
<li>I’m Ray\n</li>
<li>How are you?\n</li>
</ul>
<p>变成了下面的两个 byteBuffer</p>
<ul>
<li>Hello,world\nI’m Ray\nHo        粘包 将多个数据囤积起来发送，提高效率</li>
<li>w are you?\n                半包 由于窗口或者缓冲区大小限制，无法一次发送太多数据，所以延迟到下一次发送</li>
</ul>
<p>现在要求你编写程序，将错乱的数据恢复成原始的按 \n 分隔的数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestByteBufferExam</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 网络上有多条数据发送给服务端，数据之间使用 \n 进行分隔</span></span><br><span class="line"><span class="comment">     * 但由于某种原因这些数据在接收时，被进行了重新组合，例如原始数据有3条为</span></span><br><span class="line"><span class="comment">     * ● Hello,world\n</span></span><br><span class="line"><span class="comment">     * ● I&#x27;m Ray\n</span></span><br><span class="line"><span class="comment">     * ● How are you?\n</span></span><br><span class="line"><span class="comment">     * 变成了下面的两个 byteBuffer</span></span><br><span class="line"><span class="comment">     * ● Hello,world\nI&#x27;m Ray\nHo  粘包 将多个数据囤积起来发送，提高效率</span></span><br><span class="line"><span class="comment">     * ● w are you?\n                   半包，由于窗口或者缓冲区大小限制，无法一次发送太多数据，所以延迟到下一次发送</span></span><br><span class="line"><span class="comment">     * 现在要求你编写程序，将错乱的数据恢复成原始的按 \n 分隔的数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">source</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">32</span>);</span><br><span class="line">        source.put(<span class="string">&quot;Hello,world\nI&#x27;m Ray\nHo&quot;</span>.getBytes());</span><br><span class="line">        split(source);</span><br><span class="line">        source.put(<span class="string">&quot;w are you?\n&quot;</span>.getBytes());</span><br><span class="line">        split(source);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">split</span><span class="params">(ByteBuffer source)</span>&#123;</span><br><span class="line">        source.flip();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; source.limit(); i++) &#123;</span><br><span class="line">            <span class="comment">// 遍历到换行符即找到一条完整消息</span></span><br><span class="line">            <span class="keyword">if</span>(source.get(i)==<span class="string">&#x27;\n&#x27;</span>)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> i - source.position() + <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 将这条完整消息存入新的 ByteBuffer</span></span><br><span class="line">                <span class="comment">// 分配对应容量的 ByteBuffer</span></span><br><span class="line">                <span class="type">ByteBuffer</span> <span class="variable">target</span> <span class="operator">=</span> ByteBuffer.allocate(size);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 从 source 读，向 target 写</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; size; j++) &#123;</span><br><span class="line">                    target.put(source.get(j));</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                debugAll(target);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        source.compact(); <span class="comment">// 未读数据向前移动</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://blog-1314261683.cos.ap-chengdu.myqcloud.com/image/Netty/网络粘包闭包.png" alt="网络粘包闭包"></p>
<h1 id="文件编程"><a href="#文件编程" class="headerlink" title="文件编程"></a>文件编程</h1><h2 id="FileChannel"><a href="#FileChannel" class="headerlink" title="FileChannel"></a>FileChannel</h2><h3 id="⚠️-FileChannel-工作模式"><a href="#⚠️-FileChannel-工作模式" class="headerlink" title="⚠️ FileChannel 工作模式"></a>⚠️ FileChannel 工作模式</h3><p>FileChannel 只能工作在阻塞模式下</p>
<h3 id="获取"><a href="#获取" class="headerlink" title="获取"></a>获取</h3><p>不能直接打开 FileChannel，必须通过 FileInputStream、FileOutputStream 或者 RandomAccessFile 来获取 FileChannel，它们都有 getChannel 方法</p>
<ul>
<li>通过 FileInputStream 获取的 channel 只能读</li>
<li>通过 FileOutputStream 获取的 channel 只能写</li>
<li>通过 RandomAccessFile 是否能读写根据构造 RandomAccessFile 时的读写模式决定</li>
</ul>
<h3 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h3><p>会从 channel 读取数据填充 ByteBuffer，返回值表示读到了多少字节，-1 表示到达了文件的末尾</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">readBytes</span> <span class="operator">=</span> channel.read(buffer);</span><br></pre></td></tr></table></figure>
<h3 id="写入"><a href="#写入" class="headerlink" title="写入"></a>写入</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ...;</span><br><span class="line">buffer.put(...); <span class="comment">// 存入数据</span></span><br><span class="line">buffer.flip();   <span class="comment">// 切换读模式</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(buffer.hasRemaining()) &#123;</span><br><span class="line">    channel.write(buffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 while 中调用 channel.write 是因为 write 方法并不能保证一次将 buffer 中的内容全部写入 channel</p>
<h3 id="关闭"><a href="#关闭" class="headerlink" title="关闭"></a>关闭</h3><p>channel 必须关闭，不过调用了 FileInputStream、FileOutputStream 或者 RandomAccessFile 的 close 方法会间接地调用 channel 的 close 方法</p>
<h3 id="位置"><a href="#位置" class="headerlink" title="位置"></a>位置</h3><p>获取当前位置</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">pos</span> <span class="operator">=</span> channel.position();</span><br></pre></td></tr></table></figure>
<p>设置当前位置</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">newPos</span> <span class="operator">=</span> ...;</span><br><span class="line">channel.position(newPos);</span><br></pre></td></tr></table></figure>
<p>设置当前位置时，如果设置为文件的末尾</p>
<ul>
<li>这时读取会返回 -1</li>
<li>这时写入，会追加内容，但要注意如果 position 超过了文件末尾，再写入时在新内容和原末尾之间会有空洞（00）</li>
</ul>
<h3 id="大小"><a href="#大小" class="headerlink" title="大小"></a>大小</h3><p>使用 size 方法获取文件的大小</p>
<h3 id="强制写入"><a href="#强制写入" class="headerlink" title="强制写入"></a>强制写入</h3><p>操作系统出于性能的考虑，会将数据缓存，等到 channel 关闭后才写入磁盘，而不是写一次就立刻写入磁盘。可以调用 force(true)  方法将文件内容和元数据（文件的权限等信息）立刻写入磁盘。</p>
<h2 id="两个-Channel-传输数据"><a href="#两个-Channel-传输数据" class="headerlink" title="两个 Channel 传输数据"></a>两个 Channel 传输数据</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestChannelTransferTo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">                <span class="type">FileChannel</span> <span class="variable">from</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;demo-02/data.txt&quot;</span>).getChannel();</span><br><span class="line">                <span class="type">FileChannel</span> <span class="variable">to</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;demo-02/to.txt&quot;</span>).getChannel();</span><br><span class="line">        ) &#123;</span><br><span class="line">            <span class="comment">// 效率高,底层利用操作系统的零拷贝进行优化,一次最多传输 2G 数据</span></span><br><span class="line">            from.transferTo(<span class="number">0</span>,from.size(),to);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>超过 2G 数据大小的文件传输</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestChannelTransferTo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">                <span class="type">FileChannel</span> <span class="variable">from</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;demo-02/data.txt&quot;</span>).getChannel();</span><br><span class="line">                <span class="type">FileChannel</span> <span class="variable">to</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;demo-02/to.txt&quot;</span>).getChannel();</span><br><span class="line">        ) &#123;</span><br><span class="line">            <span class="comment">// 效率高,底层利用操作系统的零拷贝进行优化,一次最多传输 2G 数据</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">size</span> <span class="operator">=</span> from.size();</span><br><span class="line">            <span class="comment">// left 代表还剩多少字节</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">long</span> <span class="variable">left</span> <span class="operator">=</span> size;left&gt;<span class="number">0</span>;)&#123;</span><br><span class="line">                left -= from.transferTo((size - left), left,to);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Path"><a href="#Path" class="headerlink" title="Path"></a>Path</h2><p>JDK7 引入了 Path 和 Paths 类</p>
<ul>
<li>Path 用来表示文件路径</li>
<li>Paths 是工具类，用来获取 Path 实例</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Path</span> <span class="variable">source</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;1.txt&quot;</span>); <span class="comment">// 相对路径 使用 user.dir 环境变量来定位 1.txt</span></span><br><span class="line"></span><br><span class="line"><span class="type">Path</span> <span class="variable">source</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;d:\\1.txt&quot;</span>); <span class="comment">// 绝对路径 代表了  d:\1.txt</span></span><br><span class="line"></span><br><span class="line"><span class="type">Path</span> <span class="variable">source</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;d:/1.txt&quot;</span>); <span class="comment">// 绝对路径 同样代表了  d:\1.txt</span></span><br><span class="line"></span><br><span class="line"><span class="type">Path</span> <span class="variable">projects</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;d:\\data&quot;</span>, <span class="string">&quot;projects&quot;</span>); <span class="comment">// 代表了  d:\data\projects</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>.</code> 代表了当前路径</li>
<li><code>..</code> 代表了上一级路径</li>
</ul>
<p>例如目录结构如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">d:</span><br><span class="line">	|- data</span><br><span class="line">		|- projects</span><br><span class="line">			|- a</span><br><span class="line">			|- b</span><br></pre></td></tr></table></figure>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Path</span> <span class="variable">path</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;d:\\data\\projects\\a\\..\\b&quot;</span>);</span><br><span class="line">System.out.println(path);</span><br><span class="line">System.out.println(path.normalize()); <span class="comment">// 正常化路径</span></span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">d:\data\projects\a\..\b</span><br><span class="line">d:\data\projects\b</span><br></pre></td></tr></table></figure>
<h2 id="Files"><a href="#Files" class="headerlink" title="Files"></a>Files</h2><p>检查文件是否存在</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Path</span> <span class="variable">path</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;helloword/data.txt&quot;</span>);</span><br><span class="line">System.out.println(Files.exists(path));</span><br></pre></td></tr></table></figure>
<p>创建一级目录</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Path</span> <span class="variable">path</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;helloword/d1&quot;</span>);</span><br><span class="line">Files.createDirectory(path);</span><br></pre></td></tr></table></figure>
<ul>
<li>如果目录已存在，会抛异常 FileAlreadyExistsException</li>
<li>不能一次创建多级目录，否则会抛异常 NoSuchFileException</li>
</ul>
<p>创建多级目录用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Path</span> <span class="variable">path</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;helloword/d1/d2&quot;</span>);</span><br><span class="line">Files.createDirectories(path);</span><br></pre></td></tr></table></figure>
<p>拷贝文件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Path</span> <span class="variable">source</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;helloword/data.txt&quot;</span>);</span><br><span class="line"><span class="type">Path</span> <span class="variable">target</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;helloword/target.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">Files.copy(source, target);</span><br></pre></td></tr></table></figure>
<ul>
<li>如果文件已存在，会抛异常 FileAlreadyExistsException</li>
</ul>
<p>如果希望用 source 覆盖掉 target，需要用 StandardCopyOption 来控制</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Files.copy(source, target, StandardCopyOption.REPLACE_EXISTING);</span><br></pre></td></tr></table></figure>
<p>移动文件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Path</span> <span class="variable">source</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;helloword/data.txt&quot;</span>);</span><br><span class="line"><span class="type">Path</span> <span class="variable">target</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;helloword/data.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">Files.move(source, target, StandardCopyOption.ATOMIC_MOVE);</span><br></pre></td></tr></table></figure>
<ul>
<li>StandardCopyOption.ATOMIC_MOVE 保证文件移动的原子性</li>
</ul>
<p>删除文件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Path</span> <span class="variable">target</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;helloword/target.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">Files.delete(target);</span><br></pre></td></tr></table></figure>
<ul>
<li>如果文件不存在，会抛异常 NoSuchFileException</li>
</ul>
<p>删除目录</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Path</span> <span class="variable">target</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;helloword/d1&quot;</span>);</span><br><span class="line"></span><br><span class="line">Files.delete(target);</span><br></pre></td></tr></table></figure>
<ul>
<li>如果目录还有内容，会抛异常 DirectoryNotEmptyException</li>
</ul>
<p>遍历目录文件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">func1</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">AtomicInteger</span> <span class="variable">dirCount</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line">    <span class="type">AtomicInteger</span> <span class="variable">fileCount</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line"></span><br><span class="line">    Files.walkFileTree(Paths.get(<span class="string">&quot;/Users/ray/goland/sdk/go1.18&quot;</span>),<span class="keyword">new</span> <span class="title class_">SimpleFileVisitor</span>&lt;Path&gt;()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> FileVisitResult <span class="title function_">preVisitDirectory</span><span class="params">(Path dir, BasicFileAttributes attrs)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;===&gt;&quot;</span>+dir);</span><br><span class="line">            dirCount.incrementAndGet();</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">super</span>.preVisitDirectory(dir, attrs);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> FileVisitResult <span class="title function_">visitFile</span><span class="params">(Path file, BasicFileAttributes attrs)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">            System.out.println(file);</span><br><span class="line">            fileCount.incrementAndGet();</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">super</span>.visitFile(file, attrs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;dirCount : &quot;</span> + dirCount);</span><br><span class="line">    System.out.println(<span class="string">&quot;fileCount : &quot;</span> + fileCount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>统计 .go 文件数目</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">fun2</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">AtomicInteger</span> <span class="variable">goCount</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line">    Files.walkFileTree(Paths.get(<span class="string">&quot;/Users/ray/goland/sdk/go1.18&quot;</span>),<span class="keyword">new</span> <span class="title class_">SimpleFileVisitor</span>&lt;Path&gt;()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> FileVisitResult <span class="title function_">visitFile</span><span class="params">(Path file, BasicFileAttributes attrs)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">            <span class="keyword">if</span> (file.toString().endsWith(<span class="string">&quot;.go&quot;</span>)) &#123;</span><br><span class="line">                System.out.println(file);</span><br><span class="line">                goCount.incrementAndGet();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">super</span>.visitFile(file, attrs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;goCount : &quot;</span> + goCount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>删除多级目录</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">func3</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    Files.walkFileTree(Paths.get(<span class="string">&quot;Path&quot;</span>),<span class="keyword">new</span> <span class="title class_">SimpleFileVisitor</span>&lt;Path&gt;()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> FileVisitResult <span class="title function_">preVisitDirectory</span><span class="params">(Path dir, BasicFileAttributes attrs)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;===&gt; 进入&quot;</span> + dir);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">super</span>.preVisitDirectory(dir, attrs);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> FileVisitResult <span class="title function_">visitFile</span><span class="params">(Path file, BasicFileAttributes attrs)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">            System.out.println(file);</span><br><span class="line">            Files.delete(file);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">super</span>.visitFile(file, attrs);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> FileVisitResult <span class="title function_">postVisitDirectory</span><span class="params">(Path dir, IOException exc)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;===&gt; 退出&quot;</span> + dir);</span><br><span class="line">            Files.delete(dir);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">super</span>.postVisitDirectory(dir, exc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>拷贝多级目录</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestFilesCopy</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">String</span> <span class="variable">source</span> <span class="operator">=</span> <span class="string">&quot;D:\\source&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">target</span> <span class="operator">=</span> <span class="string">&quot;D:\\target&quot;</span>;</span><br><span class="line"></span><br><span class="line">        Files.walk(Paths.get(source)).forEach(path -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">targetName</span> <span class="operator">=</span> path.toString().replace(source, target);</span><br><span class="line">                <span class="comment">// 是目录</span></span><br><span class="line">                <span class="keyword">if</span> (Files.isDirectory(path)) &#123;</span><br><span class="line">                    Files.createDirectory(Paths.get(targetName));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 是普通文件</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (Files.isRegularFile(path)) &#123;</span><br><span class="line">                    Files.copy(path, Paths.get(targetName));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(end - start);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h1><p><a target="_blank" rel="noopener" href="https://xiaolincoding.com/network/3_tcp/tcp_interview.html#针对-tcp-应该如何-socket-编程">Socket编程</a></p>
<h2 id="阻塞-vs-非阻塞"><a href="#阻塞-vs-非阻塞" class="headerlink" title="阻塞 vs 非阻塞"></a>阻塞 vs 非阻塞</h2><h3 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h3><ul>
<li><p>阻塞模式下，相关方法都会导致线程暂停 </p>
</li>
<li><ul>
<li>ServerSocketChannel.accept 会在没有连接建立时让线程暂停</li>
<li>SocketChannel.read 会在没有数据可读时让线程暂停</li>
<li>阻塞的表现其实就是线程暂停了，暂停期间不会占用 cpu，但线程相当于闲置</li>
</ul>
</li>
<li><p>单线程下，阻塞方法之间相互影响，几乎不能正常工作，需要多线程支持</p>
</li>
<li><p>但多线程下，有新的问题，体现在以下方面 </p>
</li>
<li><ul>
<li>32 位 jvm 一个线程 320k，64 位 jvm 一个线程 1024k，如果连接数过多，必然导致 OOM，并且线程太多，反而会因为频繁上下文切换导致性能降低</li>
<li>可以采用线程池技术来减少线程数和线程上下文切换，但治标不治本，如果有很多连接建立，但长时间 inactive，会阻塞线程池中所有线程，因此不适合长连接，只适合短连接</li>
</ul>
</li>
</ul>
<p>服务端</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 0. ByteBuffer</span></span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 创建服务器通道</span></span><br><span class="line">        <span class="type">ServerSocketChannel</span> <span class="variable">server</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 绑定监听端口</span></span><br><span class="line">        server.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">8080</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 连接集合</span></span><br><span class="line">        List&lt;SocketChannel&gt; channelList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;connecting...&quot;</span>);</span><br><span class="line">            <span class="comment">// 3. 建立与客户端之间的连接, SocketChannel 用于客户端与服务器之间通信</span></span><br><span class="line">            <span class="type">SocketChannel</span> <span class="variable">socket</span> <span class="operator">=</span> server.accept();     <span class="comment">// 阻塞方法,没有客户端连接,线程停滞</span></span><br><span class="line">            log.debug(<span class="string">&quot;connected... &#123;&#125;&quot;</span>,socket);</span><br><span class="line">            channelList.add(socket);</span><br><span class="line">            <span class="comment">// 4. 接收 客户端 数据</span></span><br><span class="line">            <span class="keyword">for</span> (SocketChannel channel : channelList)&#123;</span><br><span class="line">                log.debug(<span class="string">&quot;before read... &#123;&#125;&quot;</span>,socket);</span><br><span class="line">                channel.read(buffer);   <span class="comment">// 阻塞方法,等待读取数据,没有数据,线程停滞</span></span><br><span class="line">                buffer.flip();</span><br><span class="line">                debugRead(buffer);</span><br><span class="line">                buffer.clear();</span><br><span class="line">                log.debug(<span class="string">&quot;after read... &#123;&#125;&quot;</span>,channel);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">SocketChannel</span> <span class="variable">socket</span> <span class="operator">=</span> SocketChannel.open();</span><br><span class="line">        socket.connect(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;localhost&quot;</span>,<span class="number">8080</span>));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;waiting...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="非阻塞"><a href="#非阻塞" class="headerlink" title="非阻塞"></a>非阻塞</h3><ul>
<li><p>非阻塞模式下，相关方法都不会让线程暂停 </p>
</li>
<li><ul>
<li>在 ServerSocketChannel.accept 在没有连接建立时，会返回 null，继续运行</li>
<li>SocketChannel.read 在没有数据可读时，会返回 0，但线程非阻塞，可以去执行其它 SocketChannel 的 read 或是去执行 ServerSocketChannel.accept</li>
<li>写数据时，线程只是等待数据写入 Channel 即可，无需等 Channel 通过网络把数据发送出去</li>
</ul>
</li>
<li><p>但非阻塞模式下，即使没有连接建立，和可读数据，线程仍然在不断运行，白白浪费了 cpu</p>
</li>
<li>数据复制过程中，线程实际还是阻塞的（AIO 改进的地方）</li>
</ul>
<p>服务端</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 0. ByteBuffer</span></span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 创建服务器通道</span></span><br><span class="line">        <span class="type">ServerSocketChannel</span> <span class="variable">server</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">        server.configureBlocking(<span class="literal">false</span>); <span class="comment">// 非阻塞模式</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 绑定监听端口</span></span><br><span class="line">        server.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">8080</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 连接集合</span></span><br><span class="line">        List&lt;SocketChannel&gt; channelList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// log.debug(&quot;connecting...&quot;);</span></span><br><span class="line">            <span class="comment">// 3. 建立与客户端之间的连接, SocketChannel 用于客户端与服务器之间通信</span></span><br><span class="line">            <span class="type">SocketChannel</span> <span class="variable">socket</span> <span class="operator">=</span> server.accept();</span><br><span class="line">            <span class="comment">// 阻塞方法,没有客户端连接,线程停滞</span></span><br><span class="line">            <span class="comment">// 非阻塞,没有客户端连接,线程继续执行,但 socket 为 null</span></span><br><span class="line">            <span class="keyword">if</span> (socket!=<span class="literal">null</span>) &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;connected... &#123;&#125;&quot;</span>,socket);</span><br><span class="line">                socket.configureBlocking(<span class="literal">false</span>); <span class="comment">// 非阻塞模式</span></span><br><span class="line">                channelList.add(socket);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 4. 接收 客户端 数据</span></span><br><span class="line">            <span class="keyword">for</span> (SocketChannel channel : channelList)&#123;</span><br><span class="line">                <span class="comment">// log.debug(&quot;before read... &#123;&#125;&quot;,socket);</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">read</span> <span class="operator">=</span> channel.read(buffer);</span><br><span class="line">                <span class="comment">// 阻塞方法,等待读取数据,没有数据,线程停滞</span></span><br><span class="line">                <span class="comment">// 非阻塞,没有读取到数据,线程继续执行, read 返回 0</span></span><br><span class="line">                <span class="keyword">if</span> (read &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    buffer.flip();</span><br><span class="line">                    debugRead(buffer);</span><br><span class="line">                    buffer.clear();</span><br><span class="line">                    log.debug(<span class="string">&quot;after read... &#123;&#125;&quot;</span>,channel);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端代码不变</p>
<h3 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h3><p>单线程可以配合 Selector 完成对多个 Channel 可读写事件的监控，这称之为多路复用</p>
<ul>
<li>多路复用仅针对网络 IO、普通文件 IO 没法利用多路复用</li>
<li><p>如果不用 Selector 的非阻塞模式，线程大部分时间都在做无用功，而 Selector 能够保证 </p>
</li>
<li><ul>
<li>有可连接事件时才去连接</li>
<li>有可读事件才去读取</li>
<li>有可写事件才去写入 </li>
</ul>
</li>
<li><ul>
<li><ul>
<li>限于网络传输能力，Channel 未必时时可写，一旦 Channel 可写，会触发 Selector 的可写事件</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Selector-1"><a href="#Selector-1" class="headerlink" title="Selector"></a>Selector</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">subgraph selector 版</span><br><span class="line">thread --&gt; selector</span><br><span class="line">selector --&gt; c1(channel)</span><br><span class="line">selector --&gt; c2(channel)</span><br><span class="line">selector --&gt; c3(channel)</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>好处</p>
<ul>
<li>一个线程配合 selector 就可以监控多个 channel 的事件，事件发生线程才去处理。避免非阻塞模式下所做无用功</li>
<li>让这个线程能够被充分利用</li>
<li>节约了线程的数量</li>
<li>减少了线程上下文切换</li>
</ul>
<h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br></pre></td></tr></table></figure>
<h3 id="绑定-Channel-事件"><a href="#绑定-Channel-事件" class="headerlink" title="绑定 Channel 事件"></a>绑定 Channel 事件</h3><p>也称之为注册事件，绑定的事件 selector 才会关心</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">channel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line"><span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> channel.register(selector, 绑定事件);</span><br></pre></td></tr></table></figure>
<ul>
<li>channel 必须工作在非阻塞模式</li>
<li>FileChannel 没有非阻塞模式，因此不能配合 selector 一起使用</li>
<li><p>绑定的事件类型可以有 </p>
</li>
<li><ul>
<li>connect - 客户端连接成功时触发</li>
<li>accept - 服务器端成功接受连接请求时触发</li>
<li>read - 数据可读入时触发，有因为接收能力弱，数据暂不能读入的情况</li>
<li>write - 数据可写出时触发，有因为发送能力弱，数据暂不能写出的情况</li>
</ul>
</li>
</ul>
<h3 id="监听-Channel-事件"><a href="#监听-Channel-事件" class="headerlink" title="监听 Channel 事件"></a>监听 Channel 事件</h3><p>可以通过下面三种方法来监听是否有事件发生，方法的返回值代表有多少 channel 发生了事件</p>
<p>方法1：阻塞直到绑定事件发生</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> selector.select();</span><br></pre></td></tr></table></figure>
<p>方法2：阻塞直到绑定事件发生，或是超时（时间单位为 ms）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> selector.select(<span class="type">long</span> timeout);</span><br></pre></td></tr></table></figure>
<p>方法3：不会阻塞，也就是不管有没有事件，立刻返回，自己根据返回值检查是否有事件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> selector.selectNow();</span><br></pre></td></tr></table></figure>
<h4 id="💡-select-何时不阻塞"><a href="#💡-select-何时不阻塞" class="headerlink" title="💡 select 何时不阻塞"></a>💡 select 何时不阻塞</h4><ul>
<li><p>事件发生时 </p>
</li>
<li><ul>
<li>客户端发起连接请求，会触发 accept 事件</li>
<li>客户端发送数据过来，客户端正常、异常关闭时，都会触发 read 事件，另外如果发送的数据大于 buffer 缓冲区，会触发多次读取事件</li>
<li>channel 可写，会触发 write 事件</li>
<li>在 linux 下 nio bug 发生时</li>
</ul>
</li>
<li><p>调用 selector.wakeup()</p>
</li>
<li>调用 selector.close()</li>
<li>selector 所在线程 interrupt</li>
</ul>
<h3 id="处理-accept-事件"><a href="#处理-accept-事件" class="headerlink" title="处理 accept 事件"></a>处理 accept 事件</h3><p>服务端</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 创建 Selector,管理多个 Channel</span></span><br><span class="line">        <span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line"></span><br><span class="line">        <span class="type">ServerSocketChannel</span> <span class="variable">server</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">        server.configureBlocking(<span class="literal">false</span>); <span class="comment">// 非阻塞模式</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 建立 Selector 和 Channel 的联系 (注册)</span></span><br><span class="line">        <span class="comment">// 通过 SelectionKey 定位 事件所属的 Channel</span></span><br><span class="line">        <span class="type">SelectionKey</span> <span class="variable">serverKey</span> <span class="operator">=</span> server.register(selector, <span class="number">0</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="comment">// 服务端 key 只关注 accept 事件</span></span><br><span class="line">        serverKey.interestOps(SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">        log.debug(<span class="string">&quot;register key &#123;&#125;&quot;</span>,serverKey);</span><br><span class="line"></span><br><span class="line">        server.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">8080</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 3. select 方法 : 监听事件,没有事件发生,线程阻塞,有事件,线程向下执行</span></span><br><span class="line">            <span class="comment">// 之前的事件发生但未处理,线程也不会阻塞,继续执行</span></span><br><span class="line">            selector.select();</span><br><span class="line">            <span class="comment">// 4. 处理事件 : selectedKeys() 包含所有发生的事件</span></span><br><span class="line">            Iterator&lt;SelectionKey&gt; keys = selector.selectedKeys().iterator();</span><br><span class="line">            <span class="keyword">while</span>(keys.hasNext())&#123;</span><br><span class="line">                <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> keys.next();</span><br><span class="line">                log.debug(<span class="string">&quot;key &#123;&#125;&quot;</span>,key);</span><br><span class="line">                <span class="type">ServerSocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> (ServerSocketChannel) key.channel();</span><br><span class="line">                <span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> channel.accept();</span><br><span class="line">                log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>,socketChannel);</span><br><span class="line">                <span class="comment">// key.cancel(); 事件发生后，要么处理，要么取消</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">SocketChannel</span> <span class="variable">socket</span> <span class="operator">=</span> SocketChannel.open();</span><br><span class="line">        socket.connect(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;localhost&quot;</span>,<span class="number">8080</span>));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;waiting...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="💡-事件发生后能否不处理"><a href="#💡-事件发生后能否不处理" class="headerlink" title="💡 事件发生后能否不处理"></a>💡 事件发生后能否不处理</h4><p>事件发生后，要么处理，要么取消（cancel），不能什么都不做，否则下次该事件仍会触发，这是因为 NIO 底层使用的是水平触发</p>
<h3 id="处理-read-事件"><a href="#处理-read-事件" class="headerlink" title="处理 read 事件"></a>处理 read 事件</h3><p>服务端</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 创建 Selector,管理多个 Channel</span></span><br><span class="line">        <span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line"></span><br><span class="line">        <span class="type">ServerSocketChannel</span> <span class="variable">server</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">        server.configureBlocking(<span class="literal">false</span>); <span class="comment">// 非阻塞模式</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 建立 Selector 和 Channel 的联系 (注册)</span></span><br><span class="line">        <span class="comment">// 通过 SelectionKey 定位 事件所属的 Channel</span></span><br><span class="line">        <span class="type">SelectionKey</span> <span class="variable">serverKey</span> <span class="operator">=</span> server.register(selector, <span class="number">0</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="comment">// 服务端 key 只关注 accept 事件</span></span><br><span class="line">        serverKey.interestOps(SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">        log.debug(<span class="string">&quot;register key &#123;&#125;&quot;</span>,serverKey);</span><br><span class="line"></span><br><span class="line">        server.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">8080</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 3. select 方法 : 监听事件,没有事件发生,线程阻塞,有事件,线程向下执行</span></span><br><span class="line">            <span class="comment">// 之前的事件发生但未处理,线程也不会阻塞,继续执行</span></span><br><span class="line">            selector.select();</span><br><span class="line">            <span class="comment">// 4. 处理事件 : selectedKeys() 包含所有发生的事件</span></span><br><span class="line">            Iterator&lt;SelectionKey&gt; keys = selector.selectedKeys().iterator();</span><br><span class="line">            <span class="keyword">while</span>(keys.hasNext())&#123;</span><br><span class="line">                <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> keys.next();</span><br><span class="line">                log.debug(<span class="string">&quot;key &#123;&#125;&quot;</span>,key);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 5. 根据事件类型分别处理</span></span><br><span class="line">                <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">                    <span class="type">ServerSocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> (ServerSocketChannel) key.channel();</span><br><span class="line">                    <span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> channel.accept();</span><br><span class="line">                    socketChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">                    <span class="type">SelectionKey</span> <span class="variable">socketKey</span> <span class="operator">=</span> socketChannel.register(selector, <span class="number">0</span>, <span class="literal">null</span>);</span><br><span class="line">                    socketKey.interestOps(SelectionKey.OP_READ);</span><br><span class="line">                    log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>,socketChannel);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable())&#123;</span><br><span class="line">                    <span class="type">SocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> (SocketChannel) key.channel();  <span class="comment">// 触发事件的 channel</span></span><br><span class="line">                    <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">16</span>);</span><br><span class="line">                    channel.read(buffer);</span><br><span class="line">                    buffer.flip();</span><br><span class="line">                    debugRead(buffer);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 处理完毕,必须将事件移除</span></span><br><span class="line">                <span class="comment">// 否则再次遍历时,对应的 channel 事件已经处理,为 null,就会报空指针异常</span></span><br><span class="line">                keys.remove();</span><br><span class="line"><span class="comment">//                key.cancel();</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端不变</p>
<p>开启两个客户端，修改一下发送文字，输出</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">19:47:25 [DEBUG] [main] c.n.d.nio.Server - register key sun.nio.ch.SelectionKeyImpl@4fccd51b</span><br><span class="line">19:47:42 [DEBUG] [main] c.n.d.nio.Server - key sun.nio.ch.SelectionKeyImpl@4fccd51b</span><br><span class="line">19:47:42 [DEBUG] [main] c.n.d.nio.Server - java.nio.channels.SocketChannel[connected <span class="built_in">local</span>=/127.0.0.1:8080 remote=/127.0.0.1:58800]</span><br><span class="line">19:48:06 [DEBUG] [main] c.n.d.nio.Server - key sun.nio.ch.SelectionKeyImpl@4fccd51b</span><br><span class="line">19:48:06 [DEBUG] [main] c.n.d.nio.Server - java.nio.channels.SocketChannel[connected <span class="built_in">local</span>=/127.0.0.1:8080 remote=/127.0.0.1:58805]</span><br><span class="line">19:48:20 [DEBUG] [main] c.n.d.nio.Server - key sun.nio.ch.SelectionKeyImpl@1c2c22f3</span><br><span class="line">+--------+-------------------- <span class="built_in">read</span> -----------------------+----------------+</span><br><span class="line">position: [0], <span class="built_in">limit</span>: [6]</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 68 65 6c 6c 6f 21                               |hello!          |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">19:48:34 [DEBUG] [main] c.n.d.nio.Server - key sun.nio.ch.SelectionKeyImpl@1c2c22f3</span><br><span class="line">+--------+-------------------- <span class="built_in">read</span> -----------------------+----------------+</span><br><span class="line">position: [0], <span class="built_in">limit</span>: [6]</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 77 6f 72 6c 64 21                               |world!          |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure>
<h4 id="💡-为何要-keys-remove"><a href="#💡-为何要-keys-remove" class="headerlink" title="💡 为何要 keys.remove()"></a>💡 为何要 keys.remove()</h4><p>因为 select 在事件发生后，就会将相关的 key 放入 selectedKeys 集合，但不会在处理完后从 selectedKeys 集合中移除，需要我们自己编码删除。例如</p>
<ul>
<li>第一次触发了 serverkey 上的 accept 事件，处理完事件之后将 对应 channel 的 accept 事件移除，但并没有移除 serverkey</li>
<li>第二次触发了 socketkey 上的 read 事件，但这时 selectedKeys 中还有上次的 serverkey ，在处理时因为没有真正的 serverSocket 连上了，就会导致空指针异常</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://blog-1314261683.cos.ap-chengdu.myqcloud.com/image/Netty/为什么需要keys.remove(" alt="为什么需要keys.remove()">.png)</p>
<h4 id="💡-cancel-的作用"><a href="#💡-cancel-的作用" class="headerlink" title="💡 cancel 的作用"></a>💡 cancel 的作用</h4><p>cancel 会取消注册在 selector 上的 channel，并从 keys 集合中删除 key 后续不会再监听事件</p>
<h4 id="⚠️-不处理边界的问题"><a href="#⚠️-不处理边界的问题" class="headerlink" title="⚠️ 不处理边界的问题"></a>⚠️ 不处理边界的问题</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 创建 Selector,管理多个 Channel</span></span><br><span class="line">        <span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line"></span><br><span class="line">        <span class="type">ServerSocketChannel</span> <span class="variable">server</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">        server.configureBlocking(<span class="literal">false</span>); <span class="comment">// 非阻塞模式</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 建立 Selector 和 Channel 的联系 (注册)</span></span><br><span class="line">        <span class="comment">// 通过 SelectionKey 定位 事件所属的 Channel</span></span><br><span class="line">        <span class="type">SelectionKey</span> <span class="variable">serverKey</span> <span class="operator">=</span> server.register(selector, <span class="number">0</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="comment">// 服务端 key 只关注 accept 事件</span></span><br><span class="line">        serverKey.interestOps(SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">        log.debug(<span class="string">&quot;server key &#123;&#125;&quot;</span>,serverKey);</span><br><span class="line"></span><br><span class="line">        server.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">8080</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 3. select 方法 : 监听事件,没有事件发生,线程阻塞,有事件,线程向下执行</span></span><br><span class="line">            <span class="comment">// 之前的事件发生但未处理,线程也不会阻塞,继续执行</span></span><br><span class="line">            selector.select();</span><br><span class="line">            <span class="comment">// 4. 处理事件 : selectedKeys() 包含所有发生的事件</span></span><br><span class="line">            Iterator&lt;SelectionKey&gt; keys = selector.selectedKeys().iterator();</span><br><span class="line">            <span class="keyword">while</span>(keys.hasNext())&#123;</span><br><span class="line">                <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> keys.next();</span><br><span class="line">                log.debug(<span class="string">&quot;key &#123;&#125;&quot;</span>,key);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 5. 根据事件类型分别处理</span></span><br><span class="line">                <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">                    <span class="type">ServerSocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> (ServerSocketChannel) key.channel();</span><br><span class="line">                    <span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> channel.accept();</span><br><span class="line">                    socketChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">                    <span class="type">SelectionKey</span> <span class="variable">socketKey</span> <span class="operator">=</span> socketChannel.register(selector, <span class="number">0</span>, <span class="literal">null</span>);</span><br><span class="line">                    socketKey.interestOps(SelectionKey.OP_READ);</span><br><span class="line">                    log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>,socketChannel);</span><br><span class="line">                    log.debug(<span class="string">&quot;socketKey &#123;&#125;&quot;</span>,socketKey);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable())&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="type">SocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> (SocketChannel) key.channel();  <span class="comment">// 触发事件的 channel</span></span><br><span class="line">                        <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">4</span>);</span><br><span class="line">                        <span class="type">int</span> <span class="variable">read</span> <span class="operator">=</span> channel.read(buffer);</span><br><span class="line">                        <span class="keyword">if</span> (read==-<span class="number">1</span>)&#123;  <span class="comment">// 正常断开 read = -1</span></span><br><span class="line">                            key.cancel();</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            buffer.flip();</span><br><span class="line">                            System.out.println(StandardCharsets.UTF_8.decode(buffer));</span><br><span class="line">                            <span class="comment">// debugRead(buffer);</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                        key.cancel();   <span class="comment">// 异常断开 取消注册在 selector 上的 channel，并从 keys 集合中删除 key 后续不会再监听事件</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 处理完毕,必须将事件移除</span></span><br><span class="line">                <span class="comment">// 否则再次遍历时,对应的 channel 事件已经处理,为 null,就会报空指针异常</span></span><br><span class="line">                keys.remove();</span><br><span class="line">                <span class="comment">// key.cancel();</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>hi 正常输出</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://blog-1314261683.cos.ap-chengdu.myqcloud.com/image/Netty/边界问题1.png" alt="边界问题1"></p>
<p>hello 被拆分 hell o</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://blog-1314261683.cos.ap-chengdu.myqcloud.com/image/Netty/边界问题2.png" alt="边界问题2"></p>
<p>中文乱码且被拆分为多个部分</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://blog-1314261683.cos.ap-chengdu.myqcloud.com/image/Netty/边界问题3.png" alt="边界问题3"></p>
<h4 id="处理消息的边界"><a href="#处理消息的边界" class="headerlink" title="处理消息的边界"></a>处理消息的边界</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://blog-1314261683.cos.ap-chengdu.myqcloud.com/image/Netty/处理边界问题.png" alt="处理边界问题"></p>
<ul>
<li>一种思路是固定消息长度，数据包大小一样，服务器按预定长度读取，缺点是浪费带宽，即使是比预定长度小的数据，也分配预定长度大小</li>
<li>另一种思路是按分隔符拆分，缺点是效率低</li>
<li><p>TLV 格式，即 Type 类型、Length 长度、Value 数据，类型和长度已知的情况下，就可以方便获取消息大小，分配合适的 buffer，缺点是 buffer 需要提前分配，如果内容过大，则影响 server 吞吐量 </p>
</li>
<li><ul>
<li>Http 1.1 是 TLV 格式</li>
<li>Http 2.0 是 LTV 格式</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram </span><br><span class="line">participant c1 as 客户端1</span><br><span class="line">participant s as 服务器</span><br><span class="line">participant b1 as ByteBuffer1</span><br><span class="line">participant b2 as ByteBuffer2</span><br><span class="line">c1 -&gt;&gt; s: 发送 01234567890abcdefray\n</span><br><span class="line">s -&gt;&gt; b1: 第一次 read 存入 01234567890abcdef</span><br><span class="line">s -&gt;&gt; b2: 扩容</span><br><span class="line">b1 -&gt;&gt; b2: 拷贝 01234567890abcdef</span><br><span class="line">s -&gt;&gt; b2: 第二次 read 存入 ray\n</span><br><span class="line">b2 -&gt;&gt; b2: 01234567890abcdefray\n</span><br></pre></td></tr></table></figure>
<p>服务端</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 创建 Selector,管理多个 Channel</span></span><br><span class="line">        <span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line"></span><br><span class="line">        <span class="type">ServerSocketChannel</span> <span class="variable">server</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">        server.configureBlocking(<span class="literal">false</span>); <span class="comment">// 非阻塞模式</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 建立 Selector 和 Channel 的联系 (注册)</span></span><br><span class="line">        <span class="comment">// 通过 SelectionKey 定位 事件所属的 Channel</span></span><br><span class="line">        <span class="type">SelectionKey</span> <span class="variable">serverKey</span> <span class="operator">=</span> server.register(selector, <span class="number">0</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="comment">// 服务端 key 只关注 accept 事件</span></span><br><span class="line">        serverKey.interestOps(SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">        log.debug(<span class="string">&quot;server key &#123;&#125;&quot;</span>,serverKey);</span><br><span class="line"></span><br><span class="line">        server.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">8080</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 3. select 方法 : 监听事件,没有事件发生,线程阻塞,有事件,线程向下执行</span></span><br><span class="line">            <span class="comment">// 之前的事件发生但未处理,线程也不会阻塞,继续执行</span></span><br><span class="line">            selector.select();</span><br><span class="line">            <span class="comment">// 4. 处理事件 : selectedKeys() 包含所有发生的事件</span></span><br><span class="line">            Iterator&lt;SelectionKey&gt; keys = selector.selectedKeys().iterator();</span><br><span class="line">            <span class="keyword">while</span>(keys.hasNext())&#123;</span><br><span class="line">                <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> keys.next();</span><br><span class="line">                log.debug(<span class="string">&quot;key &#123;&#125;&quot;</span>,key);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 5. 根据事件类型分别处理</span></span><br><span class="line">                <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">                    <span class="type">ServerSocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> (ServerSocketChannel) key.channel();</span><br><span class="line">                    <span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> channel.accept();</span><br><span class="line">                    socketChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">                    <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">16</span>);    <span class="comment">// 每个 socket 有一个独立的 buffer 用于传输数据</span></span><br><span class="line">                    <span class="type">SelectionKey</span> <span class="variable">socketKey</span> <span class="operator">=</span> socketChannel.register(selector, <span class="number">0</span>, buffer);   <span class="comment">// 将 buffer 作为附件关联到对应的 socketKey 上即可</span></span><br><span class="line">                    socketKey.interestOps(SelectionKey.OP_READ);</span><br><span class="line">                    log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>,socketChannel);</span><br><span class="line">                    log.debug(<span class="string">&quot;socketKey &#123;&#125;&quot;</span>,socketKey);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable())&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> (ByteBuffer) key.attachment(); <span class="comment">// 获取 key 上的附件 buffer</span></span><br><span class="line">                        <span class="type">SocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> (SocketChannel) key.channel();  <span class="comment">// 触发事件的 channel</span></span><br><span class="line">                        <span class="type">int</span> <span class="variable">read</span> <span class="operator">=</span> channel.read(buffer);</span><br><span class="line">                        <span class="keyword">if</span> (read==-<span class="number">1</span>)&#123;  <span class="comment">// 正常断开 read = -1</span></span><br><span class="line">                            key.cancel();</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            split(buffer);</span><br><span class="line">                            <span class="comment">// 由于 split 方法最终会将未读数据向前移动,而如果已经读到最大长度即 position = limit,那么此时需要扩容</span></span><br><span class="line">                            <span class="keyword">if</span> (buffer.position() == buffer.limit())&#123;</span><br><span class="line">                                <span class="type">ByteBuffer</span> <span class="variable">newBuffer</span> <span class="operator">=</span> ByteBuffer.allocate(buffer.capacity() * <span class="number">2</span>);</span><br><span class="line">                                buffer.flip(); <span class="comment">// 切换读模式</span></span><br><span class="line">                                newBuffer.put(buffer);  <span class="comment">// 新 buffer 拷贝旧 buffer</span></span><br><span class="line">                                key.attach(newBuffer); <span class="comment">// 替换绑定的旧 buffer</span></span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                        key.cancel();   <span class="comment">// 异常断开 取消注册在 selector 上的 channel，并从 keys 集合中删除 key 后续不会再监听事件</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 处理完毕,必须将事件移除</span></span><br><span class="line">                <span class="comment">// 否则再次遍历时,对应的 channel 事件已经处理,为 null,就会报空指针异常</span></span><br><span class="line">                keys.remove();</span><br><span class="line">                <span class="comment">// key.cancel();</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">split</span><span class="params">(ByteBuffer source)</span>&#123;</span><br><span class="line">        source.flip();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; source.limit(); i++) &#123;</span><br><span class="line">            <span class="comment">// 遍历到换行符即找到一条完整消息</span></span><br><span class="line">            <span class="keyword">if</span>(source.get(i)==<span class="string">&#x27;\n&#x27;</span>)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> i - source.position() + <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 将这条完整消息存入新的 ByteBuffer</span></span><br><span class="line">                <span class="comment">// 分配对应容量的 ByteBuffer</span></span><br><span class="line">                <span class="type">ByteBuffer</span> <span class="variable">target</span> <span class="operator">=</span> ByteBuffer.allocate(size);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 从 source 读，向 target 写</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; size; j++) &#123;</span><br><span class="line">                    target.put(source.get());</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                debugAll(target);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        source.compact(); <span class="comment">// 未读数据向前移动</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">SocketChannel</span> <span class="variable">socket</span> <span class="operator">=</span> SocketChannel.open();</span><br><span class="line">        socket.connect(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;localhost&quot;</span>,<span class="number">8080</span>));</span><br><span class="line">        <span class="comment">// socket.write(StandardCharsets.UTF_8.encode(&quot;hello\nworld\n&quot;));</span></span><br><span class="line">        socket.write(StandardCharsets.UTF_8.encode(<span class="string">&quot;this is a test data\ndon&#x27;t reply&quot;</span>));</span><br><span class="line">        socket.write(StandardCharsets.UTF_8.encode(<span class="string">&quot;01234567890abcdefray\n&quot;</span>));</span><br><span class="line">        System.in.read();   <span class="comment">// 阻塞方法,等待控制台输入读取</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">08:47:27 [DEBUG] [main] c.n.d.nio.Server - server key sun.nio.ch.SelectionKeyImpl@4fccd51b</span><br><span class="line">08:47:32 [DEBUG] [main] c.n.d.nio.Server - key sun.nio.ch.SelectionKeyImpl@4fccd51b</span><br><span class="line">08:47:32 [DEBUG] [main] c.n.d.nio.Server - java.nio.channels.SocketChannel[connected <span class="built_in">local</span>=/127.0.0.1:8080 remote=/127.0.0.1:61474]</span><br><span class="line">08:47:32 [DEBUG] [main] c.n.d.nio.Server - socketKey sun.nio.ch.SelectionKeyImpl@1c2c22f3</span><br><span class="line">08:47:32 [DEBUG] [main] c.n.d.nio.Server - key sun.nio.ch.SelectionKeyImpl@1c2c22f3</span><br><span class="line">08:47:32 [DEBUG] [main] c.n.d.nio.Server - key sun.nio.ch.SelectionKeyImpl@1c2c22f3</span><br><span class="line">+--------+-------------------- all ------------------------+----------------+</span><br><span class="line">position: [20], <span class="built_in">limit</span>: [20]</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 74 68 69 73 20 69 73 20 61 20 74 65 73 74 20 64 |this is a <span class="built_in">test</span> d|</span><br><span class="line">|00000010| 61 74 61 0a                                     |ata.            |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line"></span><br><span class="line">08:47:32 [DEBUG] [main] c.n.d.nio.Server - key sun.nio.ch.SelectionKeyImpl@1c2c22f3</span><br><span class="line">+--------+-------------------- all ------------------------+----------------+</span><br><span class="line">position: [32], <span class="built_in">limit</span>: [32]</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 64 6f 6e 27 74 20 72 65 70 6c 79 30 31 32 33 34 |don<span class="string">&#x27;t reply01234|</span></span><br><span class="line"><span class="string">|00000010| 35 36 37 38 39 30 61 62 63 64 65 66 72 61 79 0a |567890abcdefray.|</span></span><br><span class="line"><span class="string">+--------+-------------------------------------------------+----------------+</span></span><br></pre></td></tr></table></figure>
<h4 id="ByteBuffer-大小分配"><a href="#ByteBuffer-大小分配" class="headerlink" title="ByteBuffer 大小分配"></a>ByteBuffer 大小分配</h4><ul>
<li>每个 channel 都需要记录可能被切分的消息，因为 ByteBuffer 不能被多个 channel 共同使用，会造成数据杂乱冲突，因此需要为每个 channel 维护一个独立的 ByteBuffer。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">16</span>);    <span class="comment">// 每个 socket 有一个独立的 buffer 用于传输数据</span></span><br><span class="line"><span class="type">SelectionKey</span> <span class="variable">socketKey</span> <span class="operator">=</span> socketChannel.register(selector, <span class="number">0</span>, buffer);   <span class="comment">// 将 buffer 作为附件关联到对应的 socketKey 上即可</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>ByteBuffer 不能太大，比如一个 ByteBuffer 1Mb 的话，要支持百万连接就要 1Tb 内存，因此需要设计大小可变的 ByteBuffer </p>
</li>
<li><ul>
<li>一种思路是首先分配一个较小的 buffer，例如 4k，如果发现数据不够，再分配 8k 的 buffer，将 4k buffer 内容拷贝至 8k buffer，优点是消息连续容易处理，缺点是数据拷贝耗费性能，参考实现 <a target="_blank" rel="noopener" href="http://tutorials.jenkov.com/java-performance/resizable-array.html">http://tutorials.jenkov.com/java-performance/resizable-array.html</a></li>
<li>另一种思路是用多个数组组成 buffer，一个数组不够，把多出来的内容写入新的数组，与前面的区别是消息存储不连续解析复杂，优点是避免了拷贝引起的性能损耗</li>
</ul>
</li>
</ul>
<h3 id="处理-write-事件"><a href="#处理-write-事件" class="headerlink" title="处理 write 事件"></a>处理 write 事件</h3><h4 id="一次无法写完例子"><a href="#一次无法写完例子" class="headerlink" title="一次无法写完例子"></a>一次无法写完例子</h4><ul>
<li>非阻塞模式下，由于网络传输能力限制，缓冲区写满后无法再写入，无法保证把 buffer 中所有数据都写入 channel，因此需要追踪 write 方法的返回值（代表实际写入字节数）</li>
<li><p>用 selector 监听所有 channel 的可写事件，每个 channel 都需要一个 key 来跟踪 buffer，但这样又会导致占用内存过多，就有两阶段策略 </p>
</li>
<li><ul>
<li>当消息处理器第一次写入消息时，才将 channel 注册到 selector 上</li>
<li>selector 检查 channel 上的可写事件，如果所有的数据写完了，就取消 channel 的注册</li>
<li>如果不取消，每次可写均会触发 write 事件</li>
</ul>
</li>
</ul>
<p>服务端</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WriteServer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">ServerSocketChannel</span> <span class="variable">server</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">        server.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">        server.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">8080</span>));</span><br><span class="line"></span><br><span class="line">        <span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line">        server.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            selector.select();</span><br><span class="line">            Iterator&lt;SelectionKey&gt; keys = selector.selectedKeys().iterator();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (keys.hasNext()) &#123;</span><br><span class="line">                <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> keys.next();</span><br><span class="line">                keys.remove();</span><br><span class="line">                <span class="keyword">if</span> (key.isAcceptable())&#123;</span><br><span class="line">                    <span class="type">SocketChannel</span> <span class="variable">socket</span> <span class="operator">=</span> server.accept();</span><br><span class="line">                    socket.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">                    <span class="type">SelectionKey</span> <span class="variable">socketKey</span> <span class="operator">=</span> socket.register(selector, SelectionKey.OP_READ);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 1. 向客户端发送大量数据</span></span><br><span class="line">                    <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">500000</span>; i++) &#123;</span><br><span class="line">                        sb.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> StandardCharsets.UTF_8.encode(sb.toString());</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 2. 返回 write 实际写入的字节数</span></span><br><span class="line">                    <span class="type">int</span> <span class="variable">write</span> <span class="operator">=</span> socket.write(buffer);</span><br><span class="line">                    System.out.println(<span class="string">&quot;第一次写入 &quot;</span> + write);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 3.是否存在剩余内容</span></span><br><span class="line">                    <span class="keyword">if</span>(buffer.hasRemaining())&#123;</span><br><span class="line">                        <span class="comment">// 4. 在原有基础上再关注可写事件</span></span><br><span class="line">                        socketKey.interestOps(socketKey.interestOps() + SelectionKey.OP_WRITE);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 5. 绑定剩余内容</span></span><br><span class="line">                        socketKey.attach(buffer);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isWritable())&#123;</span><br><span class="line">                    <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> (ByteBuffer) key.attachment();</span><br><span class="line">                    <span class="type">SocketChannel</span> <span class="variable">socket</span> <span class="operator">=</span> (SocketChannel) key.channel();</span><br><span class="line">                    <span class="type">int</span> <span class="variable">write</span> <span class="operator">=</span> socket.write(buffer);</span><br><span class="line">                    System.out.println(<span class="string">&quot;可写事件中写入 &quot;</span> + write);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 6. 没有剩余内容</span></span><br><span class="line">                    <span class="keyword">if</span> (!buffer.hasRemaining())&#123;</span><br><span class="line">                        key.attach(<span class="literal">null</span>);   <span class="comment">// 取消绑定 buffer</span></span><br><span class="line">                        key.interestOps(key.interestOps() - SelectionKey.OP_WRITE); <span class="comment">// 无需再关注可写事件</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://blog-1314261683.cos.ap-chengdu.myqcloud.com/image/Netty/处理写事件1.png" alt="处理写事件1"></p>
<p>客户端</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WriteClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">SocketChannel</span> <span class="variable">socket</span> <span class="operator">=</span> SocketChannel.open();</span><br><span class="line">        socket.connect(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;localhost&quot;</span>,<span class="number">8080</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接收数据</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>*<span class="number">1024</span>);</span><br><span class="line">            count += socket.read(buffer);</span><br><span class="line">            System.out.println(count);</span><br><span class="line">            buffer.clear();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://blog-1314261683.cos.ap-chengdu.myqcloud.com/image/Netty/处理写事件2.png" alt="处理写事件2"></p>
<h4 id="💡-write-为何要取消"><a href="#💡-write-为何要取消" class="headerlink" title="💡 write 为何要取消"></a>💡 write 为何要取消</h4><p>只要向 channel 发送数据时，socket 缓冲可写，这个事件会频繁触发（相当于长连接？），因此应当只在 socket 缓冲区写不下时再关注可写事件，数据写完之后再取消关注</p>
<h3 id="更进一步"><a href="#更进一步" class="headerlink" title="更进一步"></a>更进一步</h3><h4 id="💡-利用多线程优化"><a href="#💡-利用多线程优化" class="headerlink" title="💡 利用多线程优化"></a>💡 利用多线程优化</h4><p>现在都是多核 cpu，设计时要充分考虑别让 cpu 的力量被白白浪费</p>
<p>前面的代码只有一个选择器，没有充分利用多核 cpu，如何改进呢？</p>
<p>分两组选择器</p>
<ul>
<li>单线程配一个选择器，专门处理 accept 事件</li>
<li>创建 cpu 核心数的线程，每个线程配一个选择器，轮流处理 read 事件</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MultiThreadServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        Thread.currentThread().setName(<span class="string">&quot;Boss&quot;</span>);</span><br><span class="line">        <span class="type">ServerSocketChannel</span> <span class="variable">server</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">        server.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">8080</span>));</span><br><span class="line">        server.configureBlocking(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Selector</span> <span class="variable">boss</span> <span class="operator">=</span> Selector.open();</span><br><span class="line">        <span class="type">SelectionKey</span> <span class="variable">bossKey</span> <span class="operator">=</span> server.register(boss, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 创建固定数量的 worker</span></span><br><span class="line">        <span class="type">Worker</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Worker</span>(<span class="string">&quot;worker1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            boss.select();</span><br><span class="line"></span><br><span class="line">            Iterator&lt;SelectionKey&gt; keys = boss.selectedKeys().iterator();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (keys.hasNext()) &#123;</span><br><span class="line">                <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> keys.next();</span><br><span class="line">                keys.remove();</span><br><span class="line">                <span class="keyword">if</span> (key.isAcceptable())&#123;</span><br><span class="line">                    <span class="type">SocketChannel</span> <span class="variable">socket</span> <span class="operator">=</span> server.accept();</span><br><span class="line">                    socket.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">                    log.debug(<span class="string">&quot;connected... &#123;&#125;&quot;</span>,socket.getRemoteAddress());</span><br><span class="line">                    <span class="comment">// 2. 关联 worker 的 selector ，并关注 read 事件</span></span><br><span class="line">                    log.debug(<span class="string">&quot;before register... &#123;&#125;&quot;</span>,socket.getRemoteAddress());</span><br><span class="line">                    worker.register(socket); <span class="comment">// boss 调用 初始化  , 启动 worker1</span></span><br><span class="line">                    log.debug(<span class="string">&quot;after register... &#123;&#125;&quot;</span>,socket.getRemoteAddress());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Worker</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> Thread thread;</span><br><span class="line">        <span class="keyword">private</span> Selector selector;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Atomic 原子类保证 一个 selector 持有 一个 thread</span></span><br><span class="line">        <span class="comment">// 也可以放在 构造方法中 进行初始化 ，但最好不要在构造方法中写可能抛异常的代码</span></span><br><span class="line">        <span class="keyword">private</span> <span class="type">AtomicBoolean</span> <span class="variable">register</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicBoolean</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 任务队列</span></span><br><span class="line">        <span class="keyword">private</span> ConcurrentLinkedQueue&lt;Runnable&gt; queue = <span class="keyword">new</span> <span class="title class_">ConcurrentLinkedQueue</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Worker</span><span class="params">(String name)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line"><span class="comment">//            thread = new Thread(this);</span></span><br><span class="line"><span class="comment">//            selector = Selector.open();</span></span><br><span class="line"><span class="comment">//            thread.start();</span></span><br><span class="line"><span class="comment">//            register.set(true);</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化 线程 和 selector</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(SocketChannel socket)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">            <span class="keyword">if</span> (!register.get()) &#123;</span><br><span class="line">                thread = <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="built_in">this</span>);</span><br><span class="line">                selector = Selector.open();</span><br><span class="line">                thread.start();</span><br><span class="line">                register.set(<span class="literal">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 向队列添加任务,通过 lambda 表达式 表示该任务,不会立刻执行</span></span><br><span class="line">            queue.add(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    socket.register(selector,SelectionKey.OP_READ,<span class="literal">null</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClosedChannelException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 此时仍在 Boss 线程,唤醒 select,使线程不阻塞,即放行 第一次用于 Boss 线程 客户端 socket 关联 worker 的 selector ，并关注 read 事件</span></span><br><span class="line">            selector.wakeup();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    selector.select();</span><br><span class="line">                    <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                    <span class="keyword">if</span> (task!=<span class="literal">null</span>)&#123;</span><br><span class="line">                        task.run(); <span class="comment">// 执行  socket.register(selector,SelectionKey.OP_READ,null);</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    Iterator&lt;SelectionKey&gt; keys = selector.selectedKeys().iterator();</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">while</span> (keys.hasNext()) &#123;</span><br><span class="line">                        <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> keys.next();</span><br><span class="line">                        keys.remove();</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (key.isReadable())&#123;</span><br><span class="line">                            <span class="type">SocketChannel</span> <span class="variable">socket</span> <span class="operator">=</span> (SocketChannel) key.channel();</span><br><span class="line">                            socket.configureBlocking(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">                            log.debug(<span class="string">&quot;read... &#123;&#125;&quot;</span>,socket.getRemoteAddress());</span><br><span class="line">                            <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">16</span>);</span><br><span class="line">                            socket.read(buffer);</span><br><span class="line">                            buffer.flip();</span><br><span class="line">                            debugAll(buffer);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里需要注意的是</p>
<ol>
<li>如何保证 一个 worker 对应 一个 thread？</li>
</ol>
<p>利用 原子类 做验证使其在方法中只执行一次。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Atomic 原子类保证 一个 selector 持有 一个 thread</span></span><br><span class="line"><span class="comment">// 也可以放在 构造方法中 进行初始化 ，但最好不要在构造方法中写可能抛异常的代码</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">AtomicBoolean</span> <span class="variable">register</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicBoolean</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!register.get()) &#123;</span><br><span class="line">    thread = <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="built_in">this</span>);</span><br><span class="line">    selector = Selector.open();</span><br><span class="line">    thread.start();</span><br><span class="line">   	register.set(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>如何关联 worker 的 selector？</li>
</ol>
<p>如果一开始 worker.register 就 thread.start ，那么在 selector.select(); 没有事件发生，worker 线程阻塞，boss 线程也就无法执行 socket.register(selector,SelectionKey.OP_READ,null); </p>
<p>需要改变其执行顺序。</p>
<p>这里利用 延迟队列 来实现线程间通信，并通过 wakeup 唤醒线程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 任务队列</span></span><br><span class="line"><span class="keyword">private</span> ConcurrentLinkedQueue&lt;Runnable&gt; queue = <span class="keyword">new</span> <span class="title class_">ConcurrentLinkedQueue</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// 向队列添加任务,通过 lambda 表达式 表示该任务,不会立刻执行</span></span><br><span class="line">queue.add(()-&gt;&#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">         socket.register(selector,SelectionKey.OP_READ,<span class="literal">null</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClosedChannelException e) &#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此时仍在 Boss 线程,唤醒 select,使线程不阻塞,即放行 第一次用于 Boss 线程 客户端 socket 关联 worker 的 selector ，并关注 read 事件</span></span><br><span class="line">selector.wakeup();</span><br></pre></td></tr></table></figure>
<p>也可以直接使用 wakeup</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 唤醒 select,使线程不阻塞,即放行 第一次用于 Boss 线程 客户端 socket 关联 worker 的 selector ，并关注 read 事件</span></span><br><span class="line">selector.wakeup();</span><br><span class="line">socket.register(selector,SelectionKey.OP_READ,<span class="literal">null</span>);</span><br></pre></td></tr></table></figure>
<h4 id="💡-如何拿到-cpu-个数"><a href="#💡-如何拿到-cpu-个数" class="headerlink" title="💡 如何拿到 cpu 个数"></a>💡 如何拿到 cpu 个数</h4><ul>
<li>Runtime.getRuntime().availableProcessors() 如果工作在 docker 容器下，因为容器不是物理隔离的，会拿到物理 cpu 个数，而不是容器申请时的个数</li>
<li>这个问题直到 jdk 10 才修复，使用 jvm 参数 UseContainerSupport 配置， 默认开启</li>
</ul>
<p>服务端最终版</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.netty.demo02.nio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentLinkedQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicBoolean;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> com.netty.demo02.bytebuffer.ByteBufferUtil.debugAll;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Ray</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2023/4/24 14:06</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MultiThreadServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        Thread.currentThread().setName(<span class="string">&quot;Boss&quot;</span>);</span><br><span class="line">        <span class="type">ServerSocketChannel</span> <span class="variable">server</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">        server.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">8080</span>));</span><br><span class="line">        server.configureBlocking(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Selector</span> <span class="variable">boss</span> <span class="operator">=</span> Selector.open();</span><br><span class="line">        <span class="type">SelectionKey</span> <span class="variable">bossKey</span> <span class="operator">=</span> server.register(boss, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 创建固定数量的 worker</span></span><br><span class="line">        Worker[] workers = <span class="keyword">new</span> <span class="title class_">Worker</span>[Runtime.getRuntime().availableProcessors()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; workers.length; i++) &#123;</span><br><span class="line">            workers[i] = <span class="keyword">new</span> <span class="title class_">Worker</span>(<span class="string">&quot;worker-&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">AtomicInteger</span> <span class="variable">index</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            boss.select();</span><br><span class="line"></span><br><span class="line">            Iterator&lt;SelectionKey&gt; keys = boss.selectedKeys().iterator();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (keys.hasNext()) &#123;</span><br><span class="line">                <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> keys.next();</span><br><span class="line">                keys.remove();</span><br><span class="line">                <span class="keyword">if</span> (key.isAcceptable())&#123;</span><br><span class="line">                    <span class="type">SocketChannel</span> <span class="variable">socket</span> <span class="operator">=</span> server.accept();</span><br><span class="line">                    socket.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">                    log.debug(<span class="string">&quot;connected... &#123;&#125;&quot;</span>,socket.getRemoteAddress());</span><br><span class="line">                    <span class="comment">// 2. 关联 worker 的 selector ，并关注 read 事件</span></span><br><span class="line">                    log.debug(<span class="string">&quot;before register... &#123;&#125;&quot;</span>,socket.getRemoteAddress());</span><br><span class="line">                    <span class="comment">// Round Robin 轮询</span></span><br><span class="line">                    workers[index.getAndIncrement() % workers.length].register(socket); <span class="comment">// boss 调用 初始化 , 启动 worker</span></span><br><span class="line">                    log.debug(<span class="string">&quot;after register... &#123;&#125;&quot;</span>,socket.getRemoteAddress());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Worker</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> Thread thread;</span><br><span class="line">        <span class="keyword">private</span> Selector selector;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Atomic 原子类保证 一个 selector 共享同一个 thread</span></span><br><span class="line">        <span class="comment">// 也可以放在 构造方法中 进行初始化 ，但最好不要在构造方法中写可能抛异常的代码</span></span><br><span class="line">        <span class="keyword">private</span> <span class="type">AtomicBoolean</span> <span class="variable">register</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicBoolean</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 任务队列</span></span><br><span class="line">        <span class="keyword">private</span> ConcurrentLinkedQueue&lt;Runnable&gt; queue = <span class="keyword">new</span> <span class="title class_">ConcurrentLinkedQueue</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Worker</span><span class="params">(String name)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line"><span class="comment">//            thread = new Thread(this);</span></span><br><span class="line"><span class="comment">//            selector = Selector.open();</span></span><br><span class="line"><span class="comment">//            thread.start();</span></span><br><span class="line"><span class="comment">//            register.set(true);</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化 线程 和 selector</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(SocketChannel socket)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">            <span class="keyword">if</span> (!register.get()) &#123;</span><br><span class="line">                thread = <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="built_in">this</span>);</span><br><span class="line">                selector = Selector.open();</span><br><span class="line">                thread.start();</span><br><span class="line">                register.set(<span class="literal">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 向队列添加任务,通过 lambda 表达式 表示该任务,不会立刻执行</span></span><br><span class="line">            queue.add(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    socket.register(selector,SelectionKey.OP_READ,<span class="literal">null</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClosedChannelException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 唤醒 select,使线程不阻塞,即放行 第一次用于 Boss 线程 客户端 socket 关联 worker 的 selector ，并关注 read 事件</span></span><br><span class="line">            selector.wakeup();</span><br><span class="line">            <span class="comment">// socket.register(selector,SelectionKey.OP_READ,null);</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            Thread.currentThread().setName(name);</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    selector.select();</span><br><span class="line">                    <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                    <span class="keyword">if</span> (task!=<span class="literal">null</span>)&#123;</span><br><span class="line">                        task.run(); <span class="comment">// 执行  socket.register(selector,SelectionKey.OP_READ,null);</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    Iterator&lt;SelectionKey&gt; keys = selector.selectedKeys().iterator();</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">while</span> (keys.hasNext()) &#123;</span><br><span class="line">                        <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> keys.next();</span><br><span class="line">                        keys.remove();</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (key.isReadable())&#123;</span><br><span class="line">                            <span class="type">SocketChannel</span> <span class="variable">socket</span> <span class="operator">=</span> (SocketChannel) key.channel();</span><br><span class="line">                            socket.configureBlocking(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">                            log.debug(<span class="string">&quot;read... &#123;&#125;&quot;</span>,socket.getRemoteAddress());</span><br><span class="line">                            <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">16</span>);</span><br><span class="line">                            socket.read(buffer);</span><br><span class="line">                            buffer.flip();</span><br><span class="line">                            debugAll(buffer);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h4><p>服务端</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UDPServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">try</span> (DatagramChannel channel= DatagramChannel.open()) &#123;</span><br><span class="line">            channel.socket().bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">9999</span>));</span><br><span class="line">            System.out.println(<span class="string">&quot;waiting...&quot;</span>);</span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">32</span>);</span><br><span class="line">            channel.receive(buffer);</span><br><span class="line">            buffer.flip();</span><br><span class="line">            debugAll(buffer);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UDPClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">DatagramChannel</span> <span class="variable">channel</span> <span class="operator">=</span> DatagramChannel.open()) &#123;</span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> StandardCharsets.UTF_8.encode(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">            <span class="type">InetSocketAddress</span> <span class="variable">address</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;localhost&quot;</span>,<span class="number">9999</span>);</span><br><span class="line">            channel.send(buffer,address);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="NIO-vs-BIO-vs-AIO"><a href="#NIO-vs-BIO-vs-AIO" class="headerlink" title="NIO vs BIO vs AIO"></a>NIO vs BIO vs AIO</h1><h2 id="stream-vs-channel"><a href="#stream-vs-channel" class="headerlink" title="stream vs channel"></a>stream vs channel</h2><ul>
<li>stream 不会自动缓冲数据，channel 会利用系统提供的发送缓冲区、接收缓冲区（更为底层）</li>
<li>stream 仅支持阻塞 API，channel 同时支持阻塞、非阻塞 API，网络 channel 可配合 selector 实现多路复用</li>
<li>二者均为全双工，即读写可以同时进行</li>
</ul>
<h2 id="IO-模型"><a href="#IO-模型" class="headerlink" title="IO 模型"></a>IO 模型</h2><p>同步阻塞、同步非阻塞、同步多路复用、异步阻塞（没有此情况）、异步非阻塞</p>
<ul>
<li>同步：线程自己去获取结果（一个线程）</li>
<li>异步：线程自己不去获取结果，而是由其它线程送结果（至少两个线程）</li>
</ul>
<p>当调用一次 channel.read 或 stream.read 后，会切换至操作系统内核态来完成真正数据读取，而读取又分为两个阶段，分别为：</p>
<ul>
<li>等待数据阶段</li>
<li>复制数据阶段</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://blog-1314261683.cos.ap-chengdu.myqcloud.com/image/Netty/read等待复制.png" alt="read等待复制"></p>
<p>阻塞 IO</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://blog-1314261683.cos.ap-chengdu.myqcloud.com/image/Netty/阻塞IO.png" alt="阻塞IO"></p>
<p>非阻塞 IO</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://blog-1314261683.cos.ap-chengdu.myqcloud.com/image/Netty/非阻塞IO.png" alt="非阻塞IO"></p>
<p>多路复用</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://blog-1314261683.cos.ap-chengdu.myqcloud.com/image/Netty/多路复用.png" alt="多路复用"></p>
<p>异步 IO</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://blog-1314261683.cos.ap-chengdu.myqcloud.com/image/Netty/异步IO.png" alt="异步IO"></p>
<p>阻塞 IO vs 多路复用</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://blog-1314261683.cos.ap-chengdu.myqcloud.com/image/Netty/阻塞IO2.png" alt="阻塞IO2"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://blog-1314261683.cos.ap-chengdu.myqcloud.com/image/Netty/多路复用2.png" alt="多路复用2"></p>
<h3 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h3><h4 id="传统-IO-问题"><a href="#传统-IO-问题" class="headerlink" title="传统 IO 问题"></a>传统 IO 问题</h4><p>传统的 IO 将一个文件通过 socket 写出</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;helloword/data.txt&quot;</span>);</span><br><span class="line"><span class="type">RandomAccessFile</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(file, <span class="string">&quot;r&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">byte</span>[] buf = <span class="keyword">new</span> <span class="title class_">byte</span>[(<span class="type">int</span>)f.length()];</span><br><span class="line">file.read(buf);</span><br><span class="line"></span><br><span class="line"><span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> ...;</span><br><span class="line">socket.getOutputStream().write(buf);</span><br></pre></td></tr></table></figure>
<p>内部工作流程是这样的：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://blog-1314261683.cos.ap-chengdu.myqcloud.com/image/Netty/传统IO流程.png" alt="传统IO流程"></p>
<ol>
<li>java 本身并不具备 IO 读写能力，因此 read 方法调用后，要从 java 程序的<strong>用户态</strong>切换至<strong>内核态</strong>，去调用操作系统（Kernel）的读能力，将数据读入<strong>内核缓冲区</strong>。这期间用户线程阻塞，操作系统使用 DMA（Direct Memory Access）来实现文件读，其间也不会使用 CPU</li>
</ol>
<p>DMA 也可以理解为硬件单元，用来解放 CPU 完成文件 IO</p>
<ol>
<li>从<strong>内核态</strong>切换回<strong>用户态</strong>，将数据从<strong>内核缓冲区</strong>读入<strong>用户缓冲区</strong>（即 byte[] buf），这期间 CPU 会参与拷贝，无法利用 DMA </li>
<li>调用 write 方法，这时将数据从<strong>用户缓冲区</strong>（byte[] buf）写入 <strong>socket 缓冲区</strong>，CPU 会参与拷贝 </li>
<li>接下来要向网卡写数据，这项能力 java 又不具备，因此又得从<strong>用户态</strong>切换至<strong>内核态</strong>，调用操作系统的写能力，使用 DMA 将 <strong>socket 缓冲区</strong>的数据写入网卡，不会使用 CPU</li>
</ol>
<p>可以看到中间环节较多，java 的 IO 实际不是物理设备级别的读写，而是缓存的复制，底层的真正读写是操作系统来完成的</p>
<ul>
<li>用户态与内核态的切换发生了 3 次，这个操作比较重量级</li>
<li>数据拷贝了共 4 次</li>
</ul>
<h4 id="NIO-优化"><a href="#NIO-优化" class="headerlink" title="NIO 优化"></a>NIO 优化</h4><p>通过 DirectByteBuf</p>
<ul>
<li>ByteBuffer.allocate(10)  HeapByteBuffer 使用的还是 java 内存</li>
<li>ByteBuffer.allocateDirect(10)  DirectByteBuffer 使用的是操作系统内存</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://blog-1314261683.cos.ap-chengdu.myqcloud.com/image/Netty/NIO直接内存优化.png" alt="NIO直接内存优化"></p>
<p>大部分步骤与优化前相同，不再赘述。唯有一点：java 可以使用 DirectByteBuf 将堆外内存映射到 jvm 内存中来直接访问使用</p>
<ul>
<li>这块内存不受 jvm 垃圾回收的影响，因此内存地址固定，有助于 IO 读写</li>
<li><p>java 中的 DirectByteBuf 对象仅维护了此内存的虚引用，内存回收分成两步 </p>
</li>
<li><ul>
<li>DirectByteBuf 对象被垃圾回收，将虚引用加入引用队列</li>
<li>通过专门线程访问引用队列，根据虚引用释放堆外内存</li>
</ul>
</li>
<li><p>减少了一次数据拷贝，用户态与内核态的切换次数没有减少</p>
</li>
</ul>
<p>进一步优化（底层采用了 linux 2.1 后提供的 sendFile 方法），java 中对应着两个 channel 调用 transferTo/transferFrom 方法拷贝数据</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://blog-1314261683.cos.ap-chengdu.myqcloud.com/image/Netty/sendFile优化.png" alt="sendFile优化"></p>
<ol>
<li>java 调用 transferTo 方法后，要从 java 程序的<strong>用户态</strong>切换至<strong>内核态</strong>，使用 DMA 将数据读入<strong>内核缓冲区</strong>，不会使用 CPU</li>
<li>数据从<strong>内核缓冲区</strong>传输到 <strong>socket 缓冲区</strong>，CPU 会参与拷贝</li>
<li>最后使用 DMA 将 <strong>socket 缓冲区</strong>的数据写入网卡，不会使用 CPU</li>
</ol>
<p>可以看到</p>
<ul>
<li>只发生了一次用户态与内核态的切换</li>
<li>数据拷贝了 3 次</li>
</ul>
<p>进一步优化（linux 2.4）</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://blog-1314261683.cos.ap-chengdu.myqcloud.com/image/Netty/Linux2.4优化.png" alt="Linux2.4优化"></p>
<ol>
<li>java 调用 transferTo 方法后，要从 java 程序的<strong>用户态</strong>切换至<strong>内核态</strong>，使用 DMA 将数据读入<strong>内核缓冲区</strong>，不会使用 CPU</li>
<li>只会将一些 offset 和 length 信息拷入 <strong>socket 缓冲区</strong>，几乎无消耗</li>
<li>使用 DMA 将 <strong>内核缓冲区</strong>的数据写入网卡，不会使用 CPU</li>
</ol>
<p>整个过程仅只发生了一次用户态与内核态的切换，数据拷贝了 2 次。所谓的【零拷贝】，并不是真正无拷贝，而是不会拷贝重复数据到 jvm 内存中，零拷贝的优点有</p>
<ul>
<li>更少的用户态与内核态的切换</li>
<li>不利用 CPU 计算，减少 CPU 缓存伪共享</li>
<li>零拷贝适合小文件传输</li>
</ul>
<h3 id="AIO"><a href="#AIO" class="headerlink" title="AIO"></a>AIO</h3><p>AIO 用来解决数据复制阶段的阻塞问题</p>
<ul>
<li>同步意味着，在进行读写操作时，线程需要等待结果，还是相当于闲置</li>
<li>异步意味着，在进行读写操作时，线程不必等待结果，而是将来由操作系统来通过回调方式由另外的线程来获得结果</li>
</ul>
<p>异步模型需要底层操作系统（Kernel）提供支持</p>
<ul>
<li>Windows 系统通过 IOCP 实现了真正的异步 IO</li>
<li>Linux 系统异步 IO 在 2.6 版本引入，但其底层实现还是用多路复用模拟了异步 IO，性能没有优势</li>
</ul>
<h4 id="文件-AIO"><a href="#文件-AIO" class="headerlink" title="文件 AIO"></a>文件 AIO</h4><p>先来看看 AsynchronousFileChannel</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AioDemo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">AsynchronousFileChannel</span> <span class="variable">s</span> <span class="operator">=</span> </span><br><span class="line">                AsynchronousFileChannel.open(</span><br><span class="line">                	Paths.get(<span class="string">&quot;1.txt&quot;</span>), StandardOpenOption.READ);</span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">2</span>);</span><br><span class="line">            log.debug(<span class="string">&quot;begin...&quot;</span>);</span><br><span class="line">            s.read(buffer, <span class="number">0</span>, <span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">CompletionHandler</span>&lt;Integer, ByteBuffer&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">completed</span><span class="params">(Integer result, ByteBuffer attachment)</span> &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;read completed...&#123;&#125;&quot;</span>, result);</span><br><span class="line">                    buffer.flip();</span><br><span class="line">                    debug(buffer);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">failed</span><span class="params">(Throwable exc, ByteBuffer attachment)</span> &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;read failed...&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        log.debug(<span class="string">&quot;do other things...&quot;</span>);</span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">13:44:56 [DEBUG] [main] c.i.aio.AioDemo1 - begin...</span><br><span class="line">13:44:56 [DEBUG] [main] c.i.aio.AioDemo1 - do other things...</span><br><span class="line">13:44:56 [DEBUG] [Thread-5] c.i.aio.AioDemo1 - read completed...2</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 61 0d                                           |a.              |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure>
<p>可以看到</p>
<ul>
<li>响应文件读取成功的是另一个线程 Thread-5</li>
<li>主线程并没有 IO 操作阻塞</li>
</ul>
<h4 id="💡-守护线程"><a href="#💡-守护线程" class="headerlink" title="💡 守护线程"></a>💡 守护线程</h4><p>默认文件 AIO 使用的线程都是守护线程，所以最后要执行 <code>System.in.read()</code> 以避免守护线程意外结束</p>
<h4 id="网络-AIO"><a href="#网络-AIO" class="headerlink" title="网络 AIO"></a>网络 AIO</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AioServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">AsynchronousServerSocketChannel</span> <span class="variable">ssc</span> <span class="operator">=</span> AsynchronousServerSocketChannel.open();</span><br><span class="line">        ssc.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">8080</span>));</span><br><span class="line">        ssc.accept(<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">AcceptHandler</span>(ssc));</span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">closeChannel</span><span class="params">(AsynchronousSocketChannel sc)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;[%s] %s close\n&quot;</span>, Thread.currentThread().getName(), sc.getRemoteAddress());</span><br><span class="line">            sc.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ReadHandler</span> <span class="keyword">implements</span> <span class="title class_">CompletionHandler</span>&lt;Integer, ByteBuffer&gt; &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> AsynchronousSocketChannel sc;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">ReadHandler</span><span class="params">(AsynchronousSocketChannel sc)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.sc = sc;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">completed</span><span class="params">(Integer result, ByteBuffer attachment)</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (result == -<span class="number">1</span>) &#123;</span><br><span class="line">                    closeChannel(sc);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.printf(<span class="string">&quot;[%s] %s read\n&quot;</span>, Thread.currentThread().getName(), sc.getRemoteAddress());</span><br><span class="line">                attachment.flip();</span><br><span class="line">                System.out.println(Charset.defaultCharset().decode(attachment));</span><br><span class="line">                attachment.clear();</span><br><span class="line">                <span class="comment">// 处理完第一个 read 时，需要再次调用 read 方法来处理下一个 read 事件</span></span><br><span class="line">                sc.read(attachment, attachment, <span class="built_in">this</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">failed</span><span class="params">(Throwable exc, ByteBuffer attachment)</span> &#123;</span><br><span class="line">            closeChannel(sc);</span><br><span class="line">            exc.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">WriteHandler</span> <span class="keyword">implements</span> <span class="title class_">CompletionHandler</span>&lt;Integer, ByteBuffer&gt; &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> AsynchronousSocketChannel sc;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="title function_">WriteHandler</span><span class="params">(AsynchronousSocketChannel sc)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.sc = sc;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">completed</span><span class="params">(Integer result, ByteBuffer attachment)</span> &#123;</span><br><span class="line">            <span class="comment">// 如果作为附件的 buffer 还有内容，需要再次 write 写出剩余内容</span></span><br><span class="line">            <span class="keyword">if</span> (attachment.hasRemaining()) &#123;</span><br><span class="line">                sc.write(attachment);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">failed</span><span class="params">(Throwable exc, ByteBuffer attachment)</span> &#123;</span><br><span class="line">            exc.printStackTrace();</span><br><span class="line">            closeChannel(sc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">AcceptHandler</span> <span class="keyword">implements</span> <span class="title class_">CompletionHandler</span>&lt;AsynchronousSocketChannel, Object&gt; &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> AsynchronousServerSocketChannel ssc;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">AcceptHandler</span><span class="params">(AsynchronousServerSocketChannel ssc)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.ssc = ssc;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">completed</span><span class="params">(AsynchronousSocketChannel sc, Object attachment)</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.printf(<span class="string">&quot;[%s] %s connected\n&quot;</span>, Thread.currentThread().getName(), sc.getRemoteAddress());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">16</span>);</span><br><span class="line">            <span class="comment">// 读事件由 ReadHandler 处理</span></span><br><span class="line">            sc.read(buffer, buffer, <span class="keyword">new</span> <span class="title class_">ReadHandler</span>(sc));</span><br><span class="line">            <span class="comment">// 写事件由 WriteHandler 处理</span></span><br><span class="line">            sc.write(Charset.defaultCharset().encode(<span class="string">&quot;server hello!&quot;</span>), ByteBuffer.allocate(<span class="number">16</span>), <span class="keyword">new</span> <span class="title class_">WriteHandler</span>(sc));</span><br><span class="line">            <span class="comment">// 处理完第一个 accpet 时，需要再次调用 accept 方法来处理下一个 accept 事件</span></span><br><span class="line">            ssc.accept(<span class="literal">null</span>, <span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">failed</span><span class="params">(Throwable exc, Object attachment)</span> &#123;</span><br><span class="line">            exc.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://blog-1314261683.cos.ap-chengdu.myqcloud.com/public/avatar2.png" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://blog-1314261683.cos.ap-chengdu.myqcloud.com/public/avatar2.png" title="头像" alt="头像"></a><div class="post-copyright__author_name">hiriki</div><div class="post-copyright__author_desc"></div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="http://www.sherry.zone/posts/e5d14cce.html">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('http://www.sherry.zone/posts/e5d14cce.html')">NIO基础</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="http://www.sherry.zone/posts/e5d14cce.html"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=NIO基础&amp;url=http://www.sherry.zone/posts/e5d14cce.html&amp;pic=https://blog-1314261683.cos.ap-chengdu.myqcloud.com/public/四月.jpeg" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><script>function copyCurrentPageUrl() {
  var currentPageUrl = window.location.href;
  var input = document.createElement("input");
  input.setAttribute("value", currentPageUrl);
  document.body.appendChild(input);
  input.select();
  input.setSelectionRange(0, 99999);
  document.execCommand("copy");
  document.body.removeChild(input);
}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://www.sherry.zone" target="_blank">「hirikiのblog」</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/NIO/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>NIO<span class="tagsPageCount">1</span></a></div></div></div><div class="post_share"><div class="social-share" data-image="https://blog-1314261683.cos.ap-chengdu.myqcloud.com/public/四月.jpeg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/16518a5d.html"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://blog-1314261683.cos.ap-chengdu.myqcloud.com/public/三月.jpeg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">单调栈</div></div></a></div><div class="next-post pull-right"><a href="/posts/21d654b6.html"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://blog-1314261683.cos.ap-chengdu.myqcloud.com/public/四月.jpeg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Netty入门</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="anzhiyufont anzhiyu-icon-comments"></i><span> 评论</span></div><div class="comment-randomInfo"><a onclick="anzhiyu.addRandomCommentInfo()" href="javascript:void(0)" style="display: none">匿名评论</a></div><div class="comment-tips" id="comment-tips"><span>✅ 你无需删除空行，直接评论以获取最佳展示效果</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div><div class="comment-barrage"></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info__sayhi" id="author-info__sayhi" onclick="anzhiyu.changeSayHelloText()"></div><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://blog-1314261683.cos.ap-chengdu.myqcloud.com/public/avatar2.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-status"><img class="g-status" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2021/01/15/f20deafe04aa9.png" alt="status"/></div></div><div class="author-info__description"><div style="line-height:1.38;margin:0.6rem 0;margin-top:4rem;text-align:center;color:rgba(255, 255, 255, 0.8);"><b style="color:#fff">分享、热爱、提升</b><b style="color:#fff"></b><b style="color:#fff"></b></div></div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/"><h1 class="author-info__name">hiriki</h1><div class="author-info__desc"></div></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://github.com/hiriki" target="_blank" title="Github"><i class="anzhiyufont anzhiyu-icon-github"></i></a><a class="social-icon faa-parent animated-hover" href="https://space.bilibili.com/401060750" target="_blank" title="BiliBili"><i class="anzhiyufont anzhiyu-icon-bilibili"></i></a></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#NIO-%E4%B8%89%E5%A4%A7%E7%BB%84%E4%BB%B6"><span class="toc-number">1.</span> <span class="toc-text">NIO 三大组件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Channel-amp-Buffer"><span class="toc-number">1.1.</span> <span class="toc-text">Channel &amp; Buffer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Selector"><span class="toc-number">1.2.</span> <span class="toc-text">Selector</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%89%88%E8%AE%BE%E8%AE%A1"><span class="toc-number">1.2.1.</span> <span class="toc-text">多线程版设计</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%9A%A0%EF%B8%8F-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%89%88%E7%BC%BA%E7%82%B9"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">⚠️ 多线程版缺点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%89%88%E8%AE%BE%E8%AE%A1"><span class="toc-number">1.2.2.</span> <span class="toc-text">线程池版设计</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%9A%A0%EF%B8%8F-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%89%88%E7%BC%BA%E7%82%B9"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">⚠️ 线程池版缺点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#selector-%E7%89%88%E8%AE%BE%E8%AE%A1-%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.2.3.</span> <span class="toc-text">selector 版设计 线程的实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ByteBuffer"><span class="toc-number">2.</span> <span class="toc-text">ByteBuffer</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ByteBuffer-%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF"><span class="toc-number">2.1.</span> <span class="toc-text">ByteBuffer 正确使用姿势</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ByteBuffer-%E7%BB%93%E6%9E%84"><span class="toc-number">2.2.</span> <span class="toc-text">ByteBuffer 结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%92%A1-%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-number">2.2.1.</span> <span class="toc-text">💡 调试工具类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ByteBuffer-%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95"><span class="toc-number">2.3.</span> <span class="toc-text">ByteBuffer 常见方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E9%85%8D%E7%A9%BA%E9%97%B4"><span class="toc-number">2.3.1.</span> <span class="toc-text">分配空间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%91-buffer-%E5%86%99%E5%85%A5%E6%95%B0%E6%8D%AE"><span class="toc-number">2.3.2.</span> <span class="toc-text">向 buffer 写入数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E-buffer-%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE"><span class="toc-number">2.3.3.</span> <span class="toc-text">从 buffer 读取数据</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#mark-%E5%92%8C-reset"><span class="toc-number">2.3.3.1.</span> <span class="toc-text">mark 和 reset</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8E-ByteBuffer-%E4%BA%92%E8%BD%AC"><span class="toc-number">2.3.4.</span> <span class="toc-text">字符串与 ByteBuffer 互转</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9A%A0%EF%B8%8F-Buffer-%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="toc-number">2.3.5.</span> <span class="toc-text">⚠️ Buffer 的线程安全</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Scattering-Reads-%E5%88%86%E6%95%A3%E8%AF%BB"><span class="toc-number">2.3.6.</span> <span class="toc-text">Scattering Reads 分散读</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Gathering-Writes-%E9%9B%86%E4%B8%AD%E5%86%99"><span class="toc-number">2.3.7.</span> <span class="toc-text">Gathering Writes 集中写</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%83%E4%B9%A0%EF%BC%9A%E7%BD%91%E7%BB%9C%E7%B2%98%E5%8C%85%E5%8D%8A%E5%8C%85%E9%97%AE%E9%A2%98"><span class="toc-number">2.3.8.</span> <span class="toc-text">练习：网络粘包半包问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%BC%96%E7%A8%8B"><span class="toc-number">3.</span> <span class="toc-text">文件编程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#FileChannel"><span class="toc-number">3.1.</span> <span class="toc-text">FileChannel</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9A%A0%EF%B8%8F-FileChannel-%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.1.1.</span> <span class="toc-text">⚠️ FileChannel 工作模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96"><span class="toc-number">3.1.2.</span> <span class="toc-text">获取</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96"><span class="toc-number">3.1.3.</span> <span class="toc-text">读取</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99%E5%85%A5"><span class="toc-number">3.1.4.</span> <span class="toc-text">写入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E9%97%AD"><span class="toc-number">3.1.5.</span> <span class="toc-text">关闭</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%8D%E7%BD%AE"><span class="toc-number">3.1.6.</span> <span class="toc-text">位置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%A7%E5%B0%8F"><span class="toc-number">3.1.7.</span> <span class="toc-text">大小</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%BA%E5%88%B6%E5%86%99%E5%85%A5"><span class="toc-number">3.1.8.</span> <span class="toc-text">强制写入</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%A4%E4%B8%AA-Channel-%E4%BC%A0%E8%BE%93%E6%95%B0%E6%8D%AE"><span class="toc-number">3.2.</span> <span class="toc-text">两个 Channel 传输数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Path"><span class="toc-number">3.3.</span> <span class="toc-text">Path</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Files"><span class="toc-number">3.4.</span> <span class="toc-text">Files</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="toc-number">4.</span> <span class="toc-text">网络编程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%BB%E5%A1%9E-vs-%E9%9D%9E%E9%98%BB%E5%A1%9E"><span class="toc-number">4.1.</span> <span class="toc-text">阻塞 vs 非阻塞</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%BB%E5%A1%9E"><span class="toc-number">4.1.1.</span> <span class="toc-text">阻塞</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E%E9%98%BB%E5%A1%9E"><span class="toc-number">4.1.2.</span> <span class="toc-text">非阻塞</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8"><span class="toc-number">4.1.3.</span> <span class="toc-text">多路复用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Selector-1"><span class="toc-number">4.2.</span> <span class="toc-text">Selector</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA"><span class="toc-number">4.2.1.</span> <span class="toc-text">创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%91%E5%AE%9A-Channel-%E4%BA%8B%E4%BB%B6"><span class="toc-number">4.2.2.</span> <span class="toc-text">绑定 Channel 事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%91%E5%90%AC-Channel-%E4%BA%8B%E4%BB%B6"><span class="toc-number">4.2.3.</span> <span class="toc-text">监听 Channel 事件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%F0%9F%92%A1-select-%E4%BD%95%E6%97%B6%E4%B8%8D%E9%98%BB%E5%A1%9E"><span class="toc-number">4.2.3.1.</span> <span class="toc-text">💡 select 何时不阻塞</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%84%E7%90%86-accept-%E4%BA%8B%E4%BB%B6"><span class="toc-number">4.2.4.</span> <span class="toc-text">处理 accept 事件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%F0%9F%92%A1-%E4%BA%8B%E4%BB%B6%E5%8F%91%E7%94%9F%E5%90%8E%E8%83%BD%E5%90%A6%E4%B8%8D%E5%A4%84%E7%90%86"><span class="toc-number">4.2.4.1.</span> <span class="toc-text">💡 事件发生后能否不处理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%84%E7%90%86-read-%E4%BA%8B%E4%BB%B6"><span class="toc-number">4.2.5.</span> <span class="toc-text">处理 read 事件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%F0%9F%92%A1-%E4%B8%BA%E4%BD%95%E8%A6%81-keys-remove"><span class="toc-number">4.2.5.1.</span> <span class="toc-text">💡 为何要 keys.remove()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%F0%9F%92%A1-cancel-%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">4.2.5.2.</span> <span class="toc-text">💡 cancel 的作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%9A%A0%EF%B8%8F-%E4%B8%8D%E5%A4%84%E7%90%86%E8%BE%B9%E7%95%8C%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">4.2.5.3.</span> <span class="toc-text">⚠️ 不处理边界的问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E6%B6%88%E6%81%AF%E7%9A%84%E8%BE%B9%E7%95%8C"><span class="toc-number">4.2.5.4.</span> <span class="toc-text">处理消息的边界</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ByteBuffer-%E5%A4%A7%E5%B0%8F%E5%88%86%E9%85%8D"><span class="toc-number">4.2.5.5.</span> <span class="toc-text">ByteBuffer 大小分配</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%84%E7%90%86-write-%E4%BA%8B%E4%BB%B6"><span class="toc-number">4.2.6.</span> <span class="toc-text">处理 write 事件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E6%AC%A1%E6%97%A0%E6%B3%95%E5%86%99%E5%AE%8C%E4%BE%8B%E5%AD%90"><span class="toc-number">4.2.6.1.</span> <span class="toc-text">一次无法写完例子</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%F0%9F%92%A1-write-%E4%B8%BA%E4%BD%95%E8%A6%81%E5%8F%96%E6%B6%88"><span class="toc-number">4.2.6.2.</span> <span class="toc-text">💡 write 为何要取消</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9B%B4%E8%BF%9B%E4%B8%80%E6%AD%A5"><span class="toc-number">4.2.7.</span> <span class="toc-text">更进一步</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%F0%9F%92%A1-%E5%88%A9%E7%94%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%8C%96"><span class="toc-number">4.2.7.1.</span> <span class="toc-text">💡 利用多线程优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%F0%9F%92%A1-%E5%A6%82%E4%BD%95%E6%8B%BF%E5%88%B0-cpu-%E4%B8%AA%E6%95%B0"><span class="toc-number">4.2.7.2.</span> <span class="toc-text">💡 如何拿到 cpu 个数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#UDP"><span class="toc-number">4.2.7.3.</span> <span class="toc-text">UDP</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#NIO-vs-BIO-vs-AIO"><span class="toc-number">5.</span> <span class="toc-text">NIO vs BIO vs AIO</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#stream-vs-channel"><span class="toc-number">5.1.</span> <span class="toc-text">stream vs channel</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IO-%E6%A8%A1%E5%9E%8B"><span class="toc-number">5.2.</span> <span class="toc-text">IO 模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%B6%E6%8B%B7%E8%B4%9D"><span class="toc-number">5.2.1.</span> <span class="toc-text">零拷贝</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%A0%E7%BB%9F-IO-%E9%97%AE%E9%A2%98"><span class="toc-number">5.2.1.1.</span> <span class="toc-text">传统 IO 问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#NIO-%E4%BC%98%E5%8C%96"><span class="toc-number">5.2.1.2.</span> <span class="toc-text">NIO 优化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AIO"><span class="toc-number">5.2.2.</span> <span class="toc-text">AIO</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6-AIO"><span class="toc-number">5.2.2.1.</span> <span class="toc-text">文件 AIO</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%F0%9F%92%A1-%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B"><span class="toc-number">5.2.2.2.</span> <span class="toc-text">💡 守护线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C-AIO"><span class="toc-number">5.2.2.3.</span> <span class="toc-text">网络 AIO</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/e59f4313.html" title="docker部署kafka单机和集群"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://blog-1314261683.cos.ap-chengdu.myqcloud.com/public/四月.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="docker部署kafka单机和集群"/></a><div class="content"><a class="title" href="/posts/e59f4313.html" title="docker部署kafka单机和集群">docker部署kafka单机和集群</a><time datetime="2024-04-09T04:11:00.000Z" title="发表于 2024-04-09 12:11:00">2024-04-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/715fdec2.html" title="LVS实现负载均衡"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://blog-1314261683.cos.ap-chengdu.myqcloud.com/public/二月.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="LVS实现负载均衡"/></a><div class="content"><a class="title" href="/posts/715fdec2.html" title="LVS实现负载均衡">LVS实现负载均衡</a><time datetime="2024-02-15T13:46:00.000Z" title="发表于 2024-02-15 21:46:00">2024-02-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/65774202.html" title="docker搭建zookeeper集群"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://blog-1314261683.cos.ap-chengdu.myqcloud.com/public/十二月.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="docker搭建zookeeper集群"/></a><div class="content"><a class="title" href="/posts/65774202.html" title="docker搭建zookeeper集群">docker搭建zookeeper集群</a><time datetime="2023-12-18T12:44:00.000Z" title="发表于 2023-12-18 20:44:00">2023-12-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/e1b193a2.html" title="docker搭建etcd集群和etcdkeeper"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://blog-1314261683.cos.ap-chengdu.myqcloud.com/public/十二月.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="docker搭建etcd集群和etcdkeeper"/></a><div class="content"><a class="title" href="/posts/e1b193a2.html" title="docker搭建etcd集群和etcdkeeper">docker搭建etcd集群和etcdkeeper</a><time datetime="2023-12-09T17:20:00.000Z" title="发表于 2023-12-10 01:20:00">2023-12-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/a7df08d6.html" title="2-3树"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://blog-1314261683.cos.ap-chengdu.myqcloud.com/public/十月.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="2-3树"/></a><div class="content"><a class="title" href="/posts/a7df08d6.html" title="2-3树">2-3树</a><time datetime="2023-10-15T09:35:00.000Z" title="发表于 2023-10-15 17:35:00">2023-10-15</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div id="footer_deal"><a class="deal_link" href="mailto:sherry2124@163.com" title="email"><i class="anzhiyufont anzhiyu-icon-envelope"></i></a><a class="deal_link" href="https://www.sherry.zone" title="微博"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a><a class="deal_link" href="https://www.sherry.zone" title="facebook"><i class="anzhiyufont anzhiyu-icon-facebook1"></i></a><a class="deal_link" href="https://www.sherry.zone" title="RSS"><i class="anzhiyufont anzhiyu-icon-rss"></i></a><img class="footer_mini_logo" title="返回顶部" alt="返回顶部" onclick="anzhiyu.scrollToDest(0, 500)" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://blog-1314261683.cos.ap-chengdu.myqcloud.com/public/avatar2.png" size="50px"/><a class="deal_link" target="_blank" rel="noopener" href="https://github.com/hiriki" title="Github"><i class="anzhiyufont anzhiyu-icon-github"></i></a><a class="deal_link" target="_blank" rel="noopener" href="https://space.bilibili.com/401060750" title="Bilibili"><i class="anzhiyufont anzhiyu-icon-bilibili"></i></a><a class="deal_link" href="https://www.sherry.zone" title="抖音"><i class="anzhiyufont anzhiyu-icon-tiktok"></i></a><a class="deal_link" href="https://www.sherry.zone" title="CC"><i class="anzhiyufont anzhiyu-icon-copyright-line"></i></a></div><div id="workboard"><img class="workSituationImg boardsign" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shields.io/badge/hirikiの小屋-上班摸鱼中-6adea8?style=social&amp;logo=cakephp" alt="什么时候能够实现财富自由呀~" title="什么时候能够实现财富自由呀~"/><div id="runtimeTextTip"></div></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" data-title="博客框架为Hexo_v5.4.0" title="博客框架为Hexo_v5.4.0"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.1.5/img/badge/Frame-Hexo.svg" alt="博客框架为Hexo_v5.4.0"/></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" data-title="本站项目由Github托管" title="本站项目由Github托管"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.1.5/img/badge/Source-Github.svg" alt="本站项目由Github托管"/></a></p></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2022 - 2024 By <a class="footer-bar-link" href="/" title="hiriki" target="_blank">hiriki</a></div></div><div id="footer-type-tips"></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu" title="主题">主题</a><a class="footer-bar-link" target="_blank" rel="noopener" href="https://beian.miit.gov.cn/" title="渝ICP备-2024028106号">渝ICP备-2024028106号</a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">56</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">34</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">6</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 归档</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/photos/"><span> 相册</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/comments/"><span> 留言</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/about/"><span> 关于</span></a></div></div></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="anzhiyufont anzhiyu-icon-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="algolia-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><button class="search-close-button"><i class="anzhiyufont anzhiyu-icon-xmark"></i></button></nav><div class="search-wrap"><div id="algolia-search-input"></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-info"><div class="algolia-stats"></div><div class="algolia-poweredBy"></div></div></div></div></div><div id="search-mask"></div></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script async src="/anzhiyu/random.js"></script><script async="async">(function () {
  var grt = new Date("6/25/2022 10:10:00"); //设置网站上线时间
  var now = new Date();
  var dnum;
  var hnum;
  var mnum;
  var snum;
  var nowHour;

  // 计算并更新天数、小时数、分钟数和秒数
  function updateTime() {
    now = new Date(); // 更新 now 的值
    nowHour = now.getHours(); // 更新 nowHour 的值
    var days = (now - grt) / 1000 / 60 / 60 / 24;
    dnum = Math.floor(days);
    var hours = (now - grt) / 1000 / 60 / 60 - 24 * dnum;
    hnum = Math.floor(hours);
    if (String(hnum).length == 1) {
      hnum = "0" + hnum;
    }
    var minutes = (now - grt) / 1000 / 60 - 24 * 60 * dnum - 60 * hnum;
    mnum = Math.floor(minutes);
    if (String(mnum).length == 1) {
      mnum = "0" + mnum;
    }
    var seconds = (now - grt) / 1000 - 24 * 60 * 60 * dnum - 60 * 60 * hnum - 60 * mnum;
    snum = Math.round(seconds);
    if (String(snum).length == 1) {
      snum = "0" + snum;
    }
  }

  // 更新网页中显示的网站运行时间
  function updateHtml() {
    const footer = document.getElementById("footer");
    if (!footer) return
    let currentTimeHtml = "";
    if (nowHour < 18 && nowHour >= 10) {
      // 如果是上班时间，默认就是"安知鱼-上班摸鱼中.svg"图片，不需要更改
      currentTimeHtml = `本站居然运行了 ${dnum} 天<span id='runtime'> ${hnum} 小时 ${mnum} 分 ${snum} 秒 </span><i class='anzhiyufont anzhiyu-icon-heartbeat' style='color:red'></i>`;
    } else {
      // 如果是下班时间，插入"安知鱼-下班啦.svg"图片
      let img = document.querySelector("#workboard .workSituationImg");
      if (img != null) {
        img.src = "https://blog-1314261683.cos.ap-chengdu.myqcloud.com/public/svg/foot.svg";
        img.title = "下班了就该开开心心的玩耍，嘿嘿~";
        img.alt = "下班了就该开开心心的玩耍，嘿嘿~";
      }

      currentTimeHtml = `本站居然运行了 ${dnum} 天<span id='runtime'> ${hnum} 小时 ${mnum} 分 ${snum} 秒 </span><i class='anzhiyufont anzhiyu-icon-heartbeat' style='color:red'></i>`;
    }

    if (document.getElementById("runtimeTextTip")) {
      document.getElementById("runtimeTextTip").innerHTML = currentTimeHtml;
    }
  }

  setInterval(() => {
    updateTime();
    updateHtml();
  }, 1000);
})();</script><script src="https://cdn.cbd.int/algoliasearch@4.18.0/dist/algoliasearch-lite.umd.js"></script><script src="https://cdn.cbd.int/instantsearch.js@4.60.0/dist/instantsearch.production.min.js"></script><script src="/js/search/algolia.js"></script><div class="js-pjax"><script>(() => {
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://twikoo.sherry.pub/',
      region: '',
      onCommentLoaded: () => {
        anzhiyu.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') setTimeout(runFn,0)
    else getScript('https://cdn.cbd.int/twikoo@1.6.25/dist/twikoo.all.min.js').then(runFn)
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://twikoo.sherry.pub/',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(res => {
      countELement.textContent = res[0].count
    }).catch(err => {
      console.error(err)
    })
  }

  const runFn = () => {
    init();
    GLOBAL_CONFIG_SITE.isPost && getCount()
  }

  if ('Twikoo' === 'Twikoo' || !false) {
    if (false) anzhiyu.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else {
      loadTwikoo()
    }
  } else {
    window.loadOtherComment = loadTwikoo
  }
})()</script><input type="hidden" name="page-type" id="page-type" value="post"></div><script>window.addEventListener('load', () => {
  const changeContent = (content) => {
    if (content === '') return content

    content = content.replace(/<img.*?src="(.*?)"?[^\>]+>/ig, '[图片]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[链接]') // replace url
    content = content.replace(/<pre><code>.*?<\/pre>/gi, '[代码]') // replace code
    content = content.replace(/<[^>]+>/g,"") // remove html tag

    if (content.length > 150) {
      content = content.substring(0,150) + '...'
    }
    return content
  }

  const getComment = () => {
    const runTwikoo = () => {
      twikoo.getRecentComments({
        envId: 'https://twikoo.sherry.pub/',
        region: '',
        pageSize: 6,
        includeReply: true
      }).then(function (res) {
        const twikooArray = res.map(e => {
          return {
            'content': changeContent(e.comment),
            'avatar': e.avatar,
            'nick': e.nick,
            'url': e.url + '#' + e.id,
            'date': new Date(e.created).toISOString()
          }
        })

        saveToLocal.set('twikoo-newest-comments', JSON.stringify(twikooArray), 10/(60*24))
        generateHtml(twikooArray)
      }).catch(function (err) {
        const $dom = document.querySelector('#card-newest-comments .aside-list')
        $dom.textContent= "无法获取评论，请确认相关配置是否正确"
      })
    }

    if (typeof twikoo === 'object') {
      runTwikoo()
    } else {
      getScript('https://cdn.cbd.int/twikoo@1.6.25/dist/twikoo.all.min.js').then(runTwikoo)
    }
  }

  const generateHtml = array => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class=\'aside-list-item\'>'

        if (true) {
          const name = 'data-lazy-src'
          result += `<a href='${array[i].url}' class='thumbnail'><img ${name}='${array[i].avatar}' alt='${array[i].nick}'><div class='name'><span>${array[i].nick} </span></div></a>`
        }
        
        result += `<div class='content'>
        <a class='comment' href='${array[i].url}' title='${array[i].content}'>${array[i].content}</a>
        <time datetime="${array[i].date}">${anzhiyu.diffDate(array[i].date, true)}</time></div>
        </div>`
      }
    } else {
      result += '没有评论'
    }

    let $dom = document.querySelector('#card-newest-comments .aside-list')
    $dom && ($dom.innerHTML= result)
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh($dom)
  }

  const newestCommentInit = () => {
    if (document.querySelector('#card-newest-comments .aside-list')) {
      const data = saveToLocal.get('twikoo-newest-comments')
      if (data) {
        generateHtml(JSON.parse(data))
      } else {
        getComment()
      }
    }
  }

  newestCommentInit()
  document.addEventListener('pjax:complete', newestCommentInit)
})</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><script src="/js/anzhiyu/right_click_menu.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><script src="https://npm.elemecdn.com/echarts@4.9.0/dist/echarts.min.js"></script><script defer type="text/javascript" src="https://cdn1.tianli0.top/npm/sweetalert2@8.19.0/dist/sweetalert2.all.js"></script><script defer src="/js/lunar.js"></script><script defer src="/js/day.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["meta[property=\"og:image\"]","meta[property=\"og:title\"]","meta[property=\"og:url\"]","meta[property=\"og:type\"]","meta[property=\"og:site_name\"]","meta[property=\"og:description\"]","head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div><!-- hexo injector body_end start --><script async src="//at.alicdn.com/t/font_2032782_8d5kxvn09md.js"></script><!-- hexo injector body_end end --></body></html>